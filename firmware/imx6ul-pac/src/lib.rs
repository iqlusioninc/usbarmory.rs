#![doc = r" Peripheral Access Crate"]
#![doc = r""]
#![doc = r" Automatically generated. Do not directly modify the source code."]
#![no_std]
#![warn(missing_docs, rust_2018_idioms, unused_qualifications)]
#[doc = r" A peripheral instance"]
pub trait Peripheral {
    #[doc = r" The base address of this peripheral instance"]
    const BASE_ADDRESS: usize;
}
#[cfg(feature = "ccm_analog")]
pub use ccm_analog::CCM_ANALOG;
#[allow(non_snake_case)]
#[cfg(feature = "ccm_analog")]
#[doc = "CCM_ANALOG"]
pub mod ccm_analog {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x020c_8000;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "Analog ARM PLL control Register"]
        pub PLL_ARM: PLL_ARM,
        #[doc = "Analog ARM PLL control Register"]
        pub PLL_ARM_SET: PLL_ARM_SET,
        #[doc = "Analog ARM PLL control Register"]
        pub PLL_ARM_CLR: PLL_ARM_CLR,
        #[doc = "Analog ARM PLL control Register"]
        pub PLL_ARM_TOG: PLL_ARM_TOG,
        #[doc = "Analog USB1 480MHz PLL Control Register"]
        pub PLL_USB1: PLL_USB1,
        #[doc = "Analog USB1 480MHz PLL Control Register"]
        pub PLL_USB1_SET: PLL_USB1_SET,
        #[doc = "Analog USB1 480MHz PLL Control Register"]
        pub PLL_USB1_CLR: PLL_USB1_CLR,
        #[doc = "Analog USB1 480MHz PLL Control Register"]
        pub PLL_USB1_TOG: PLL_USB1_TOG,
        #[doc = "Analog USB2 480MHz PLL Control Register"]
        pub PLL_USB2: PLL_USB2,
        #[doc = "Analog USB2 480MHz PLL Control Register"]
        pub PLL_USB2_SET: PLL_USB2_SET,
        #[doc = "Analog USB2 480MHz PLL Control Register"]
        pub PLL_USB2_CLR: PLL_USB2_CLR,
        #[doc = "Analog USB2 480MHz PLL Control Register"]
        pub PLL_USB2_TOG: PLL_USB2_TOG,
        #[doc = "Analog System PLL Control Register"]
        pub PLL_SYS: PLL_SYS,
        #[doc = "Analog System PLL Control Register"]
        pub PLL_SYS_SET: PLL_SYS_SET,
        #[doc = "Analog System PLL Control Register"]
        pub PLL_SYS_CLR: PLL_SYS_CLR,
        #[doc = "Analog System PLL Control Register"]
        pub PLL_SYS_TOG: PLL_SYS_TOG,
        #[doc = "528MHz System PLL Spread Spectrum Register"]
        pub PLL_SYS_SS: PLL_SYS_SS,
        #[doc = "Numerator of 528MHz System PLL Fractional Loop Divider Register"]
        pub PLL_SYS_NUM: PLL_SYS_NUM,
        #[doc = "Denominator of 528MHz System PLL Fractional Loop Divider Register"]
        pub PLL_SYS_DENOM: PLL_SYS_DENOM,
        #[doc = "Analog Audio PLL control Register"]
        pub PLL_AUDIO: PLL_AUDIO,
        #[doc = "Analog Audio PLL control Register"]
        pub PLL_AUDIO_SET: PLL_AUDIO_SET,
        #[doc = "Analog Audio PLL control Register"]
        pub PLL_AUDIO_CLR: PLL_AUDIO_CLR,
        #[doc = "Analog Audio PLL control Register"]
        pub PLL_AUDIO_TOG: PLL_AUDIO_TOG,
        #[doc = "Numerator of Audio PLL Fractional Loop Divider Register"]
        pub PLL_AUDIO_NUM: PLL_AUDIO_NUM,
        #[doc = "Denominator of Audio PLL Fractional Loop Divider Register"]
        pub PLL_AUDIO_DENOM: PLL_AUDIO_DENOM,
        #[doc = "Analog Video PLL control Register"]
        pub PLL_VIDEO: PLL_VIDEO,
        #[doc = "Analog Video PLL control Register"]
        pub PLL_VIDEO_SET: PLL_VIDEO_SET,
        #[doc = "Analog Video PLL control Register"]
        pub PLL_VIDEO_CLR: PLL_VIDEO_CLR,
        #[doc = "Analog Video PLL control Register"]
        pub PLL_VIDEO_TOG: PLL_VIDEO_TOG,
        #[doc = "Numerator of Video PLL Fractional Loop Divider Register"]
        pub PLL_VIDEO_NUM: PLL_VIDEO_NUM,
        #[doc = "Denominator of Video PLL Fractional Loop Divider Register"]
        pub PLL_VIDEO_DENOM: PLL_VIDEO_DENOM,
        #[doc = "Analog ENET PLL Control Register"]
        pub PLL_ENET: PLL_ENET,
        #[doc = "Analog ENET PLL Control Register"]
        pub PLL_ENET_SET: PLL_ENET_SET,
        #[doc = "Analog ENET PLL Control Register"]
        pub PLL_ENET_CLR: PLL_ENET_CLR,
        #[doc = "Analog ENET PLL Control Register"]
        pub PLL_ENET_TOG: PLL_ENET_TOG,
        #[doc = "480MHz Clock (PLL3) Phase Fractional Divider Control Register"]
        pub PFD_480: PFD_480,
        #[doc = "480MHz Clock (PLL3) Phase Fractional Divider Control Register"]
        pub PFD_480_SET: PFD_480_SET,
        #[doc = "480MHz Clock (PLL3) Phase Fractional Divider Control Register"]
        pub PFD_480_CLR: PFD_480_CLR,
        #[doc = "480MHz Clock (PLL3) Phase Fractional Divider Control Register"]
        pub PFD_480_TOG: PFD_480_TOG,
        #[doc = "528MHz Clock (PLL2) Phase Fractional Divider Control Register"]
        pub PFD_528: PFD_528,
        #[doc = "528MHz Clock (PLL2) Phase Fractional Divider Control Register"]
        pub PFD_528_SET: PFD_528_SET,
        #[doc = "528MHz Clock (PLL2) Phase Fractional Divider Control Register"]
        pub PFD_528_CLR: PFD_528_CLR,
        #[doc = "528MHz Clock (PLL2) Phase Fractional Divider Control Register"]
        pub PFD_528_TOG: PFD_528_TOG,
        #[doc = "Miscellaneous Register 0"]
        pub MISC0: MISC0,
        #[doc = "Miscellaneous Register 0"]
        pub MISC0_SET: MISC0_SET,
        #[doc = "Miscellaneous Register 0"]
        pub MISC0_CLR: MISC0_CLR,
        #[doc = "Miscellaneous Register 0"]
        pub MISC0_TOG: MISC0_TOG,
        #[doc = "Miscellaneous Register 1"]
        pub MISC1: MISC1,
        #[doc = "Miscellaneous Register 1"]
        pub MISC1_SET: MISC1_SET,
        #[doc = "Miscellaneous Register 1"]
        pub MISC1_CLR: MISC1_CLR,
        #[doc = "Miscellaneous Register 1"]
        pub MISC1_TOG: MISC1_TOG,
        #[doc = "Miscellaneous Register 2"]
        pub MISC2: MISC2,
        #[doc = "Miscellaneous Register 2"]
        pub MISC2_SET: MISC2_SET,
        #[doc = "Miscellaneous Register 2"]
        pub MISC2_CLR: MISC2_CLR,
        #[doc = "Miscellaneous Register 2"]
        pub MISC2_TOG: MISC2_TOG,
    }
    unsafe impl Send for Registers {}
    #[doc = "Analog ARM PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_ARM {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_ARM {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_3063;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog ARM PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_ARM_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_ARM_SET {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_3063;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog ARM PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_ARM_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_ARM_CLR {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_3063;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog ARM PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_ARM_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_ARM_TOG {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_3063;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog USB1 480MHz PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_USB1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_USB1 {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog USB1 480MHz PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_USB1_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_USB1_SET {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog USB1 480MHz PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_USB1_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_USB1_CLR {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog USB1 480MHz PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_USB1_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_USB1_TOG {
        const OFFSET: usize = 0x1c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog USB2 480MHz PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_USB2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_USB2 {
        const OFFSET: usize = 0x20;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog USB2 480MHz PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_USB2_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_USB2_SET {
        const OFFSET: usize = 0x24;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog USB2 480MHz PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_USB2_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_USB2_CLR {
        const OFFSET: usize = 0x28;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog USB2 480MHz PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_USB2_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_USB2_TOG {
        const OFFSET: usize = 0x2c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog System PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_SYS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_SYS {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_3001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog System PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_SYS_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_SYS_SET {
        const OFFSET: usize = 0x34;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_3001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog System PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_SYS_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_SYS_CLR {
        const OFFSET: usize = 0x38;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_3001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog System PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_SYS_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_SYS_TOG {
        const OFFSET: usize = 0x3c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_3001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "528MHz System PLL Spread Spectrum Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_SYS_SS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_SYS_SS {
        const OFFSET: usize = 0x40;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Numerator of 528MHz System PLL Fractional Loop Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_SYS_NUM {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_SYS_NUM {
        const OFFSET: usize = 0x50;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Denominator of 528MHz System PLL Fractional Loop Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_SYS_DENOM {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_SYS_DENOM {
        const OFFSET: usize = 0x60;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0012;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog Audio PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_AUDIO {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_AUDIO {
        const OFFSET: usize = 0x70;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_1006;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog Audio PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_AUDIO_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_AUDIO_SET {
        const OFFSET: usize = 0x74;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_1006;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog Audio PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_AUDIO_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_AUDIO_CLR {
        const OFFSET: usize = 0x78;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_1006;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog Audio PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_AUDIO_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_AUDIO_TOG {
        const OFFSET: usize = 0x7c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_1006;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Numerator of Audio PLL Fractional Loop Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_AUDIO_NUM {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_AUDIO_NUM {
        const OFFSET: usize = 0x80;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x05f5_e100;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Denominator of Audio PLL Fractional Loop Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_AUDIO_DENOM {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_AUDIO_DENOM {
        const OFFSET: usize = 0x90;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x2964_619c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog Video PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_VIDEO {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_VIDEO {
        const OFFSET: usize = 0xa0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_100c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog Video PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_VIDEO_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_VIDEO_SET {
        const OFFSET: usize = 0xa4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_100c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog Video PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_VIDEO_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_VIDEO_CLR {
        const OFFSET: usize = 0xa8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_100c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog Video PLL control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_VIDEO_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_VIDEO_TOG {
        const OFFSET: usize = 0xac;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_100c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Numerator of Video PLL Fractional Loop Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_VIDEO_NUM {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_VIDEO_NUM {
        const OFFSET: usize = 0xb0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x05f5_e100;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Denominator of Video PLL Fractional Loop Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_VIDEO_DENOM {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_VIDEO_DENOM {
        const OFFSET: usize = 0xc0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x10a2_4447;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog ENET PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_ENET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_ENET {
        const OFFSET: usize = 0xe0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_1001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog ENET PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_ENET_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_ENET_SET {
        const OFFSET: usize = 0xe4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_1001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog ENET PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_ENET_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_ENET_CLR {
        const OFFSET: usize = 0xe8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_1001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Analog ENET PLL Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PLL_ENET_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PLL_ENET_TOG {
        const OFFSET: usize = 0xec;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_1001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "480MHz Clock (PLL3) Phase Fractional Divider Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PFD_480 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PFD_480 {
        const OFFSET: usize = 0xf0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1311_100c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "480MHz Clock (PLL3) Phase Fractional Divider Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PFD_480_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PFD_480_SET {
        const OFFSET: usize = 0xf4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1311_100c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "480MHz Clock (PLL3) Phase Fractional Divider Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PFD_480_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PFD_480_CLR {
        const OFFSET: usize = 0xf8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1311_100c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "480MHz Clock (PLL3) Phase Fractional Divider Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PFD_480_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PFD_480_TOG {
        const OFFSET: usize = 0xfc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1311_100c;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "528MHz Clock (PLL2) Phase Fractional Divider Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PFD_528 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PFD_528 {
        const OFFSET: usize = 0x0100;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1018_101b;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "528MHz Clock (PLL2) Phase Fractional Divider Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PFD_528_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PFD_528_SET {
        const OFFSET: usize = 0x0104;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1018_101b;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "528MHz Clock (PLL2) Phase Fractional Divider Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PFD_528_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PFD_528_CLR {
        const OFFSET: usize = 0x0108;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1018_101b;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "528MHz Clock (PLL2) Phase Fractional Divider Control Register"]
    #[allow(non_camel_case_types)]
    pub struct PFD_528_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PFD_528_TOG {
        const OFFSET: usize = 0x010c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1018_101b;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MISC0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC0 {
        const OFFSET: usize = 0x0150;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0400_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MISC0_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC0_SET {
        const OFFSET: usize = 0x0154;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0400_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MISC0_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC0_CLR {
        const OFFSET: usize = 0x0158;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0400_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MISC0_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC0_TOG {
        const OFFSET: usize = 0x015c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0400_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MISC1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC1 {
        const OFFSET: usize = 0x0160;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MISC1_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC1_SET {
        const OFFSET: usize = 0x0164;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MISC1_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC1_CLR {
        const OFFSET: usize = 0x0168;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MISC1_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC1_TOG {
        const OFFSET: usize = 0x016c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 2"]
    #[allow(non_camel_case_types)]
    pub struct MISC2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC2 {
        const OFFSET: usize = 0x0170;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0027_2727;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 2"]
    #[allow(non_camel_case_types)]
    pub struct MISC2_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC2_SET {
        const OFFSET: usize = 0x0174;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0027_2727;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 2"]
    #[allow(non_camel_case_types)]
    pub struct MISC2_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC2_CLR {
        const OFFSET: usize = 0x0178;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0027_2727;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Miscellaneous Register 2"]
    #[allow(non_camel_case_types)]
    pub struct MISC2_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MISC2_TOG {
        const OFFSET: usize = 0x017c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0027_2727;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                PLL_ARM: PLL_ARM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ARM_SET: PLL_ARM_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ARM_CLR: PLL_ARM_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ARM_TOG: PLL_ARM_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB1: PLL_USB1 {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB1_SET: PLL_USB1_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB1_CLR: PLL_USB1_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB1_TOG: PLL_USB1_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB2: PLL_USB2 {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB2_SET: PLL_USB2_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB2_CLR: PLL_USB2_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB2_TOG: PLL_USB2_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS: PLL_SYS {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_SET: PLL_SYS_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_CLR: PLL_SYS_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_TOG: PLL_SYS_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_SS: PLL_SYS_SS {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_NUM: PLL_SYS_NUM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_DENOM: PLL_SYS_DENOM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO: PLL_AUDIO {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_SET: PLL_AUDIO_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_CLR: PLL_AUDIO_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_TOG: PLL_AUDIO_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_NUM: PLL_AUDIO_NUM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_DENOM: PLL_AUDIO_DENOM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO: PLL_VIDEO {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_SET: PLL_VIDEO_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_CLR: PLL_VIDEO_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_TOG: PLL_VIDEO_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_NUM: PLL_VIDEO_NUM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_DENOM: PLL_VIDEO_DENOM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ENET: PLL_ENET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ENET_SET: PLL_ENET_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ENET_CLR: PLL_ENET_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ENET_TOG: PLL_ENET_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PFD_480: PFD_480 {
                    _not_send_or_sync: PhantomData,
                },
                PFD_480_SET: PFD_480_SET {
                    _not_send_or_sync: PhantomData,
                },
                PFD_480_CLR: PFD_480_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PFD_480_TOG: PFD_480_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PFD_528: PFD_528 {
                    _not_send_or_sync: PhantomData,
                },
                PFD_528_SET: PFD_528_SET {
                    _not_send_or_sync: PhantomData,
                },
                PFD_528_CLR: PFD_528_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PFD_528_TOG: PFD_528_TOG {
                    _not_send_or_sync: PhantomData,
                },
                MISC0: MISC0 {
                    _not_send_or_sync: PhantomData,
                },
                MISC0_SET: MISC0_SET {
                    _not_send_or_sync: PhantomData,
                },
                MISC0_CLR: MISC0_CLR {
                    _not_send_or_sync: PhantomData,
                },
                MISC0_TOG: MISC0_TOG {
                    _not_send_or_sync: PhantomData,
                },
                MISC1: MISC1 {
                    _not_send_or_sync: PhantomData,
                },
                MISC1_SET: MISC1_SET {
                    _not_send_or_sync: PhantomData,
                },
                MISC1_CLR: MISC1_CLR {
                    _not_send_or_sync: PhantomData,
                },
                MISC1_TOG: MISC1_TOG {
                    _not_send_or_sync: PhantomData,
                },
                MISC2: MISC2 {
                    _not_send_or_sync: PhantomData,
                },
                MISC2_SET: MISC2_SET {
                    _not_send_or_sync: PhantomData,
                },
                MISC2_CLR: MISC2_CLR {
                    _not_send_or_sync: PhantomData,
                },
                MISC2_TOG: MISC2_TOG {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CCM_ANALOG"]
    pub type CCM_ANALOG = Registers;
    impl CCM_ANALOG {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                PLL_ARM: PLL_ARM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ARM_SET: PLL_ARM_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ARM_CLR: PLL_ARM_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ARM_TOG: PLL_ARM_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB1: PLL_USB1 {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB1_SET: PLL_USB1_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB1_CLR: PLL_USB1_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB1_TOG: PLL_USB1_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB2: PLL_USB2 {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB2_SET: PLL_USB2_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB2_CLR: PLL_USB2_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_USB2_TOG: PLL_USB2_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS: PLL_SYS {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_SET: PLL_SYS_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_CLR: PLL_SYS_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_TOG: PLL_SYS_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_SS: PLL_SYS_SS {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_NUM: PLL_SYS_NUM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_SYS_DENOM: PLL_SYS_DENOM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO: PLL_AUDIO {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_SET: PLL_AUDIO_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_CLR: PLL_AUDIO_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_TOG: PLL_AUDIO_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_NUM: PLL_AUDIO_NUM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_AUDIO_DENOM: PLL_AUDIO_DENOM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO: PLL_VIDEO {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_SET: PLL_VIDEO_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_CLR: PLL_VIDEO_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_TOG: PLL_VIDEO_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_NUM: PLL_VIDEO_NUM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_VIDEO_DENOM: PLL_VIDEO_DENOM {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ENET: PLL_ENET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ENET_SET: PLL_ENET_SET {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ENET_CLR: PLL_ENET_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PLL_ENET_TOG: PLL_ENET_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PFD_480: PFD_480 {
                    _not_send_or_sync: PhantomData,
                },
                PFD_480_SET: PFD_480_SET {
                    _not_send_or_sync: PhantomData,
                },
                PFD_480_CLR: PFD_480_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PFD_480_TOG: PFD_480_TOG {
                    _not_send_or_sync: PhantomData,
                },
                PFD_528: PFD_528 {
                    _not_send_or_sync: PhantomData,
                },
                PFD_528_SET: PFD_528_SET {
                    _not_send_or_sync: PhantomData,
                },
                PFD_528_CLR: PFD_528_CLR {
                    _not_send_or_sync: PhantomData,
                },
                PFD_528_TOG: PFD_528_TOG {
                    _not_send_or_sync: PhantomData,
                },
                MISC0: MISC0 {
                    _not_send_or_sync: PhantomData,
                },
                MISC0_SET: MISC0_SET {
                    _not_send_or_sync: PhantomData,
                },
                MISC0_CLR: MISC0_CLR {
                    _not_send_or_sync: PhantomData,
                },
                MISC0_TOG: MISC0_TOG {
                    _not_send_or_sync: PhantomData,
                },
                MISC1: MISC1 {
                    _not_send_or_sync: PhantomData,
                },
                MISC1_SET: MISC1_SET {
                    _not_send_or_sync: PhantomData,
                },
                MISC1_CLR: MISC1_CLR {
                    _not_send_or_sync: PhantomData,
                },
                MISC1_TOG: MISC1_TOG {
                    _not_send_or_sync: PhantomData,
                },
                MISC2: MISC2 {
                    _not_send_or_sync: PhantomData,
                },
                MISC2_SET: MISC2_SET {
                    _not_send_or_sync: PhantomData,
                },
                MISC2_CLR: MISC2_CLR {
                    _not_send_or_sync: PhantomData,
                },
                MISC2_TOG: MISC2_TOG {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "mmdc")]
pub use mmdc::MMDC;
#[allow(non_snake_case)]
#[cfg(feature = "mmdc")]
#[doc = "MMDC"]
pub mod mmdc {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x021b_0000;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "MMDC Core Control Register"]
        pub MDCTL: MDCTL,
        #[doc = "MMDC Core Power Down Control Register"]
        pub MDPDC: MDPDC,
        #[doc = "MMDC Core ODT Timing Control Register"]
        pub MDOTC: MDOTC,
        #[doc = "MMDC Core Timing Configuration Register 0"]
        pub MDCFG0: MDCFG0,
        #[doc = "MMDC Core Timing Configuration Register 1"]
        pub MDCFG1: MDCFG1,
        #[doc = "MMDC Core Timing Configuration Register 2"]
        pub MDCFG2: MDCFG2,
        #[doc = "MMDC Core Miscellaneous Register"]
        pub MDMISC: MDMISC,
        #[doc = "MMDC Core Special Command Register"]
        pub MDSCR: MDSCR,
        #[doc = "MMDC Core Refresh Control Register"]
        pub MDREF: MDREF,
        #[doc = "MMDC Core Read/Write Command Delay Register"]
        pub MDRWD: MDRWD,
        #[doc = "MMDC Core Out of Reset Delays Register"]
        pub MDOR: MDOR,
        #[doc = "MMDC Core MRR Data Register"]
        pub MDMRR: MDMRR,
        #[doc = "MMDC Core Timing Configuration Register 3"]
        pub MDCFG3LP: MDCFG3LP,
        #[doc = "MMDC Core MR4 Derating Register"]
        pub MDMR4: MDMR4,
        #[doc = "MMDC Core Address Space Partition Register"]
        pub MDASP: MDASP,
        #[doc = "MMDC Core AXI Reordering Control Register"]
        pub MAARCR: MAARCR,
        #[doc = "MMDC Core Power Saving Control and Status Register"]
        pub MAPSR: MAPSR,
        #[doc = "MMDC Core Exclusive ID Monitor Register0"]
        pub MAEXIDR0: MAEXIDR0,
        #[doc = "MMDC Core Exclusive ID Monitor Register1"]
        pub MAEXIDR1: MAEXIDR1,
        #[doc = "MMDC Core Debug and Profiling Control Register 0"]
        pub MADPCR0: MADPCR0,
        #[doc = "MMDC Core Debug and Profiling Control Register 1"]
        pub MADPCR1: MADPCR1,
        #[doc = "MMDC Core Debug and Profiling Status Register 0"]
        pub MADPSR0: MADPSR0,
        #[doc = "MMDC Core Debug and Profiling Status Register 1"]
        pub MADPSR1: MADPSR1,
        #[doc = "MMDC Core Debug and Profiling Status Register 2"]
        pub MADPSR2: MADPSR2,
        #[doc = "MMDC Core Debug and Profiling Status Register 3"]
        pub MADPSR3: MADPSR3,
        #[doc = "MMDC Core Debug and Profiling Status Register 4"]
        pub MADPSR4: MADPSR4,
        #[doc = "MMDC Core Debug and Profiling Status Register 5"]
        pub MADPSR5: MADPSR5,
        #[doc = "MMDC Core Step By Step Address Register"]
        pub MASBS0: MASBS0,
        #[doc = "MMDC Core Step By Step Address Attributes Register"]
        pub MASBS1: MASBS1,
        #[doc = "MMDC Core General Purpose Register"]
        pub MAGENP: MAGENP,
        #[doc = "MMDC PHY ZQ HW control register"]
        pub MPZQHWCTRL: MPZQHWCTRL,
        #[doc = "MMDC PHY ZQ SW control register"]
        pub MPZQSWCTRL: MPZQSWCTRL,
        #[doc = "MMDC PHY Write Leveling Configuration and Error Status Register"]
        pub MPWLGCR: MPWLGCR,
        #[doc = "MMDC PHY Write Leveling Delay Control Register 0"]
        pub MPWLDECTRL0: MPWLDECTRL0,
        #[doc = "MMDC PHY Write Leveling Delay Control Register 1"]
        pub MPWLDECTRL1: MPWLDECTRL1,
        #[doc = "MMDC PHY Write Leveling delay-line Status Register"]
        pub MPWLDLST: MPWLDLST,
        #[doc = "MMDC PHY ODT control register"]
        pub MPODTCTRL: MPODTCTRL,
        #[doc = "MMDC PHY Read DQ Byte0 Delay Register"]
        pub MPRDDQBY0DL: MPRDDQBY0DL,
        #[doc = "MMDC PHY Read DQ Byte1 Delay Register"]
        pub MPRDDQBY1DL: MPRDDQBY1DL,
        #[doc = "MMDC PHY Write DQ Byte0 Delay Register"]
        pub MPWRDQBY0DL: MPWRDQBY0DL,
        #[doc = "MMDC PHY Write DQ Byte1 Delay Register"]
        pub MPWRDQBY1DL: MPWRDQBY1DL,
        #[doc = "MMDC PHY Write DQ Byte2 Delay Register"]
        pub MPWRDQBY2DL: MPWRDQBY2DL,
        #[doc = "MMDC PHY Write DQ Byte3 Delay Register"]
        pub MPWRDQBY3DL: MPWRDQBY3DL,
        #[doc = "MMDC PHY Read DQS Gating Control Register 0"]
        pub MPDGCTRL0: MPDGCTRL0,
        #[doc = "MMDC PHY Read DQS Gating delay-line Status Register"]
        pub MPDGDLST0: MPDGDLST0,
        #[doc = "MMDC PHY Read delay-lines Configuration Register"]
        pub MPRDDLCTL: MPRDDLCTL,
        #[doc = "MMDC PHY Read delay-lines Status Register"]
        pub MPRDDLST: MPRDDLST,
        #[doc = "MMDC PHY Write delay-lines Configuration Register"]
        pub MPWRDLCTL: MPWRDLCTL,
        #[doc = "MMDC PHY Write delay-lines Status Register"]
        pub MPWRDLST: MPWRDLST,
        #[doc = "MMDC PHY CK Control Register"]
        pub MPSDCTRL: MPSDCTRL,
        #[doc = "MMDC ZQ LPDDR2 HW Control Register"]
        pub MPZQLP2CTL: MPZQLP2CTL,
        #[doc = "MMDC PHY Read Delay HW Calibration Control Register"]
        pub MPRDDLHWCTL: MPRDDLHWCTL,
        #[doc = "MMDC PHY Write Delay HW Calibration Control Register"]
        pub MPWRDLHWCTL: MPWRDLHWCTL,
        #[doc = "MMDC PHY Read Delay HW Calibration Status Register 0"]
        pub MPRDDLHWST0: MPRDDLHWST0,
        #[doc = "MMDC PHY Write Delay HW Calibration Status Register 0"]
        pub MPWRDLHWST0: MPWRDLHWST0,
        #[doc = "MMDC PHY Write Leveling HW Error Register"]
        pub MPWLHWERR: MPWLHWERR,
        #[doc = "MMDC PHY Read DQS Gating HW Status Register 0"]
        pub MPDGHWST0: MPDGHWST0,
        #[doc = "MMDC PHY Read DQS Gating HW Status Register 1"]
        pub MPDGHWST1: MPDGHWST1,
        #[doc = "MMDC PHY Pre-defined Compare Register 1"]
        pub MPPDCMPR1: MPPDCMPR1,
        #[doc = "MMDC PHY Pre-defined Compare and CA delay-line Configuration Register"]
        pub MPPDCMPR2: MPPDCMPR2,
        #[doc = "MMDC PHY SW Dummy Access Register"]
        pub MPSWDAR0: MPSWDAR0,
        #[doc = "MMDC PHY SW Dummy Read Data Register 0"]
        pub MPSWDRDR0: MPSWDRDR0,
        #[doc = "MMDC PHY SW Dummy Read Data Register 1"]
        pub MPSWDRDR1: MPSWDRDR1,
        #[doc = "MMDC PHY SW Dummy Read Data Register 2"]
        pub MPSWDRDR2: MPSWDRDR2,
        #[doc = "MMDC PHY SW Dummy Read Data Register 3"]
        pub MPSWDRDR3: MPSWDRDR3,
        #[doc = "MMDC PHY SW Dummy Read Data Register 4"]
        pub MPSWDRDR4: MPSWDRDR4,
        #[doc = "MMDC PHY SW Dummy Read Data Register 5"]
        pub MPSWDRDR5: MPSWDRDR5,
        #[doc = "MMDC PHY SW Dummy Read Data Register 6"]
        pub MPSWDRDR6: MPSWDRDR6,
        #[doc = "MMDC PHY SW Dummy Read Data Register 7"]
        pub MPSWDRDR7: MPSWDRDR7,
        #[doc = "MMDC PHY Measure Unit Register"]
        pub MPMUR0: MPMUR0,
        #[doc = "MMDC Write CA delay-line controller"]
        pub MPWRCADL: MPWRCADL,
        #[doc = "MMDC Duty Cycle Control Register"]
        pub MPDCCR: MPDCCR,
    }
    unsafe impl Send for Registers {}
    #[doc = "MMDC Core Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MDCTL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDCTL {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0311_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Power Down Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MDPDC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDPDC {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0003_0012;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core ODT Timing Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MDOTC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDOTC {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1227_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Timing Configuration Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MDCFG0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDCFG0 {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x3236_22d3;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Timing Configuration Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MDCFG1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDCFG1 {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xb6b1_8a23;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Timing Configuration Register 2"]
    #[allow(non_camel_case_types)]
    pub struct MDCFG2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDCFG2 {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x00c7_0092;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Miscellaneous Register"]
    #[allow(non_camel_case_types)]
    pub struct MDMISC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDMISC {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_1600;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Special Command Register"]
    #[allow(non_camel_case_types)]
    pub struct MDSCR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDSCR {
        const OFFSET: usize = 0x1c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Refresh Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MDREF {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDREF {
        const OFFSET: usize = 0x20;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_c000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Read/Write Command Delay Register"]
    #[allow(non_camel_case_types)]
    pub struct MDRWD {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDRWD {
        const OFFSET: usize = 0x2c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0f9f_26d2;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Out of Reset Delays Register"]
    #[allow(non_camel_case_types)]
    pub struct MDOR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDOR {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x009f_0e0e;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core MRR Data Register"]
    #[allow(non_camel_case_types)]
    pub struct MDMRR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDMRR {
        const OFFSET: usize = 0x34;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Timing Configuration Register 3"]
    #[allow(non_camel_case_types)]
    pub struct MDCFG3LP {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDCFG3LP {
        const OFFSET: usize = 0x38;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core MR4 Derating Register"]
    #[allow(non_camel_case_types)]
    pub struct MDMR4 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDMR4 {
        const OFFSET: usize = 0x3c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Address Space Partition Register"]
    #[allow(non_camel_case_types)]
    pub struct MDASP {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MDASP {
        const OFFSET: usize = 0x40;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_003f;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core AXI Reordering Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MAARCR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MAARCR {
        const OFFSET: usize = 0x0400;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x5142_01f0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Power Saving Control and Status Register"]
    #[allow(non_camel_case_types)]
    pub struct MAPSR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MAPSR {
        const OFFSET: usize = 0x0404;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_1007;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Exclusive ID Monitor Register0"]
    #[allow(non_camel_case_types)]
    pub struct MAEXIDR0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MAEXIDR0 {
        const OFFSET: usize = 0x0408;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0020_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Exclusive ID Monitor Register1"]
    #[allow(non_camel_case_types)]
    pub struct MAEXIDR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MAEXIDR1 {
        const OFFSET: usize = 0x040c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0060_0040;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Debug and Profiling Control Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MADPCR0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MADPCR0 {
        const OFFSET: usize = 0x0410;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Debug and Profiling Control Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MADPCR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MADPCR1 {
        const OFFSET: usize = 0x0414;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Debug and Profiling Status Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MADPSR0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MADPSR0 {
        const OFFSET: usize = 0x0418;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Debug and Profiling Status Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MADPSR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MADPSR1 {
        const OFFSET: usize = 0x041c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Debug and Profiling Status Register 2"]
    #[allow(non_camel_case_types)]
    pub struct MADPSR2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MADPSR2 {
        const OFFSET: usize = 0x0420;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Debug and Profiling Status Register 3"]
    #[allow(non_camel_case_types)]
    pub struct MADPSR3 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MADPSR3 {
        const OFFSET: usize = 0x0424;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Debug and Profiling Status Register 4"]
    #[allow(non_camel_case_types)]
    pub struct MADPSR4 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MADPSR4 {
        const OFFSET: usize = 0x0428;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Debug and Profiling Status Register 5"]
    #[allow(non_camel_case_types)]
    pub struct MADPSR5 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MADPSR5 {
        const OFFSET: usize = 0x042c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Step By Step Address Register"]
    #[allow(non_camel_case_types)]
    pub struct MASBS0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MASBS0 {
        const OFFSET: usize = 0x0430;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core Step By Step Address Attributes Register"]
    #[allow(non_camel_case_types)]
    pub struct MASBS1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MASBS1 {
        const OFFSET: usize = 0x0434;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Core General Purpose Register"]
    #[allow(non_camel_case_types)]
    pub struct MAGENP {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MAGENP {
        const OFFSET: usize = 0x0440;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY ZQ HW control register"]
    #[allow(non_camel_case_types)]
    pub struct MPZQHWCTRL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPZQHWCTRL {
        const OFFSET: usize = 0x0800;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xa138_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY ZQ SW control register"]
    #[allow(non_camel_case_types)]
    pub struct MPZQSWCTRL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPZQSWCTRL {
        const OFFSET: usize = 0x0804;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write Leveling Configuration and Error Status Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWLGCR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWLGCR {
        const OFFSET: usize = 0x0808;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write Leveling Delay Control Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MPWLDECTRL0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWLDECTRL0 {
        const OFFSET: usize = 0x080c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write Leveling Delay Control Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MPWLDECTRL1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWLDECTRL1 {
        const OFFSET: usize = 0x0810;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write Leveling delay-line Status Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWLDLST {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWLDLST {
        const OFFSET: usize = 0x0814;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY ODT control register"]
    #[allow(non_camel_case_types)]
    pub struct MPODTCTRL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPODTCTRL {
        const OFFSET: usize = 0x0818;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read DQ Byte0 Delay Register"]
    #[allow(non_camel_case_types)]
    pub struct MPRDDQBY0DL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPRDDQBY0DL {
        const OFFSET: usize = 0x081c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read DQ Byte1 Delay Register"]
    #[allow(non_camel_case_types)]
    pub struct MPRDDQBY1DL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPRDDQBY1DL {
        const OFFSET: usize = 0x0820;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write DQ Byte0 Delay Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWRDQBY0DL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRDQBY0DL {
        const OFFSET: usize = 0x082c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write DQ Byte1 Delay Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWRDQBY1DL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRDQBY1DL {
        const OFFSET: usize = 0x0830;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write DQ Byte2 Delay Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWRDQBY2DL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRDQBY2DL {
        const OFFSET: usize = 0x0834;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write DQ Byte3 Delay Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWRDQBY3DL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRDQBY3DL {
        const OFFSET: usize = 0x0838;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read DQS Gating Control Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MPDGCTRL0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPDGCTRL0 {
        const OFFSET: usize = 0x083c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read DQS Gating delay-line Status Register"]
    #[allow(non_camel_case_types)]
    pub struct MPDGDLST0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPDGDLST0 {
        const OFFSET: usize = 0x0844;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read delay-lines Configuration Register"]
    #[allow(non_camel_case_types)]
    pub struct MPRDDLCTL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPRDDLCTL {
        const OFFSET: usize = 0x0848;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x4040_4040;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read delay-lines Status Register"]
    #[allow(non_camel_case_types)]
    pub struct MPRDDLST {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPRDDLST {
        const OFFSET: usize = 0x084c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write delay-lines Configuration Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWRDLCTL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRDLCTL {
        const OFFSET: usize = 0x0850;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x4040_4040;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write delay-lines Status Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWRDLST {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRDLST {
        const OFFSET: usize = 0x0854;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY CK Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MPSDCTRL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSDCTRL {
        const OFFSET: usize = 0x0858;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC ZQ LPDDR2 HW Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MPZQLP2CTL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPZQLP2CTL {
        const OFFSET: usize = 0x085c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1b5f_0109;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read Delay HW Calibration Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MPRDDLHWCTL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPRDDLHWCTL {
        const OFFSET: usize = 0x0860;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write Delay HW Calibration Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWRDLHWCTL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRDLHWCTL {
        const OFFSET: usize = 0x0864;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read Delay HW Calibration Status Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MPRDDLHWST0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPRDDLHWST0 {
        const OFFSET: usize = 0x0868;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write Delay HW Calibration Status Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MPWRDLHWST0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRDLHWST0 {
        const OFFSET: usize = 0x0870;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Write Leveling HW Error Register"]
    #[allow(non_camel_case_types)]
    pub struct MPWLHWERR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWLHWERR {
        const OFFSET: usize = 0x0878;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read DQS Gating HW Status Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MPDGHWST0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPDGHWST0 {
        const OFFSET: usize = 0x087c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Read DQS Gating HW Status Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MPDGHWST1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPDGHWST1 {
        const OFFSET: usize = 0x0880;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Pre-defined Compare Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MPPDCMPR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPPDCMPR1 {
        const OFFSET: usize = 0x088c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Pre-defined Compare and CA delay-line Configuration Register"]
    #[allow(non_camel_case_types)]
    pub struct MPPDCMPR2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPPDCMPR2 {
        const OFFSET: usize = 0x0890;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0040_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Access Register"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDAR0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDAR0 {
        const OFFSET: usize = 0x0894;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Read Data Register 0"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDRDR0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDRDR0 {
        const OFFSET: usize = 0x0898;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Read Data Register 1"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDRDR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDRDR1 {
        const OFFSET: usize = 0x089c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Read Data Register 2"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDRDR2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDRDR2 {
        const OFFSET: usize = 0x08a0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Read Data Register 3"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDRDR3 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDRDR3 {
        const OFFSET: usize = 0x08a4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Read Data Register 4"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDRDR4 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDRDR4 {
        const OFFSET: usize = 0x08a8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Read Data Register 5"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDRDR5 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDRDR5 {
        const OFFSET: usize = 0x08ac;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Read Data Register 6"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDRDR6 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDRDR6 {
        const OFFSET: usize = 0x08b0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY SW Dummy Read Data Register 7"]
    #[allow(non_camel_case_types)]
    pub struct MPSWDRDR7 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPSWDRDR7 {
        const OFFSET: usize = 0x08b4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC PHY Measure Unit Register"]
    #[allow(non_camel_case_types)]
    pub struct MPMUR0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPMUR0 {
        const OFFSET: usize = 0x08b8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Write CA delay-line controller"]
    #[allow(non_camel_case_types)]
    pub struct MPWRCADL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPWRCADL {
        const OFFSET: usize = 0x08bc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "MMDC Duty Cycle Control Register"]
    #[allow(non_camel_case_types)]
    pub struct MPDCCR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl MPDCCR {
        const OFFSET: usize = 0x08c0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x2492_2492;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                MDCTL: MDCTL {
                    _not_send_or_sync: PhantomData,
                },
                MDPDC: MDPDC {
                    _not_send_or_sync: PhantomData,
                },
                MDOTC: MDOTC {
                    _not_send_or_sync: PhantomData,
                },
                MDCFG0: MDCFG0 {
                    _not_send_or_sync: PhantomData,
                },
                MDCFG1: MDCFG1 {
                    _not_send_or_sync: PhantomData,
                },
                MDCFG2: MDCFG2 {
                    _not_send_or_sync: PhantomData,
                },
                MDMISC: MDMISC {
                    _not_send_or_sync: PhantomData,
                },
                MDSCR: MDSCR {
                    _not_send_or_sync: PhantomData,
                },
                MDREF: MDREF {
                    _not_send_or_sync: PhantomData,
                },
                MDRWD: MDRWD {
                    _not_send_or_sync: PhantomData,
                },
                MDOR: MDOR {
                    _not_send_or_sync: PhantomData,
                },
                MDMRR: MDMRR {
                    _not_send_or_sync: PhantomData,
                },
                MDCFG3LP: MDCFG3LP {
                    _not_send_or_sync: PhantomData,
                },
                MDMR4: MDMR4 {
                    _not_send_or_sync: PhantomData,
                },
                MDASP: MDASP {
                    _not_send_or_sync: PhantomData,
                },
                MAARCR: MAARCR {
                    _not_send_or_sync: PhantomData,
                },
                MAPSR: MAPSR {
                    _not_send_or_sync: PhantomData,
                },
                MAEXIDR0: MAEXIDR0 {
                    _not_send_or_sync: PhantomData,
                },
                MAEXIDR1: MAEXIDR1 {
                    _not_send_or_sync: PhantomData,
                },
                MADPCR0: MADPCR0 {
                    _not_send_or_sync: PhantomData,
                },
                MADPCR1: MADPCR1 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR0: MADPSR0 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR1: MADPSR1 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR2: MADPSR2 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR3: MADPSR3 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR4: MADPSR4 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR5: MADPSR5 {
                    _not_send_or_sync: PhantomData,
                },
                MASBS0: MASBS0 {
                    _not_send_or_sync: PhantomData,
                },
                MASBS1: MASBS1 {
                    _not_send_or_sync: PhantomData,
                },
                MAGENP: MAGENP {
                    _not_send_or_sync: PhantomData,
                },
                MPZQHWCTRL: MPZQHWCTRL {
                    _not_send_or_sync: PhantomData,
                },
                MPZQSWCTRL: MPZQSWCTRL {
                    _not_send_or_sync: PhantomData,
                },
                MPWLGCR: MPWLGCR {
                    _not_send_or_sync: PhantomData,
                },
                MPWLDECTRL0: MPWLDECTRL0 {
                    _not_send_or_sync: PhantomData,
                },
                MPWLDECTRL1: MPWLDECTRL1 {
                    _not_send_or_sync: PhantomData,
                },
                MPWLDLST: MPWLDLST {
                    _not_send_or_sync: PhantomData,
                },
                MPODTCTRL: MPODTCTRL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDQBY0DL: MPRDDQBY0DL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDQBY1DL: MPRDDQBY1DL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDQBY0DL: MPWRDQBY0DL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDQBY1DL: MPWRDQBY1DL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDQBY2DL: MPWRDQBY2DL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDQBY3DL: MPWRDQBY3DL {
                    _not_send_or_sync: PhantomData,
                },
                MPDGCTRL0: MPDGCTRL0 {
                    _not_send_or_sync: PhantomData,
                },
                MPDGDLST0: MPDGDLST0 {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDLCTL: MPRDDLCTL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDLST: MPRDDLST {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDLCTL: MPWRDLCTL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDLST: MPWRDLST {
                    _not_send_or_sync: PhantomData,
                },
                MPSDCTRL: MPSDCTRL {
                    _not_send_or_sync: PhantomData,
                },
                MPZQLP2CTL: MPZQLP2CTL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDLHWCTL: MPRDDLHWCTL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDLHWCTL: MPWRDLHWCTL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDLHWST0: MPRDDLHWST0 {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDLHWST0: MPWRDLHWST0 {
                    _not_send_or_sync: PhantomData,
                },
                MPWLHWERR: MPWLHWERR {
                    _not_send_or_sync: PhantomData,
                },
                MPDGHWST0: MPDGHWST0 {
                    _not_send_or_sync: PhantomData,
                },
                MPDGHWST1: MPDGHWST1 {
                    _not_send_or_sync: PhantomData,
                },
                MPPDCMPR1: MPPDCMPR1 {
                    _not_send_or_sync: PhantomData,
                },
                MPPDCMPR2: MPPDCMPR2 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDAR0: MPSWDAR0 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR0: MPSWDRDR0 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR1: MPSWDRDR1 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR2: MPSWDRDR2 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR3: MPSWDRDR3 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR4: MPSWDRDR4 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR5: MPSWDRDR5 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR6: MPSWDRDR6 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR7: MPSWDRDR7 {
                    _not_send_or_sync: PhantomData,
                },
                MPMUR0: MPMUR0 {
                    _not_send_or_sync: PhantomData,
                },
                MPWRCADL: MPWRCADL {
                    _not_send_or_sync: PhantomData,
                },
                MPDCCR: MPDCCR {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "MMDC"]
    pub type MMDC = Registers;
    impl MMDC {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                MDCTL: MDCTL {
                    _not_send_or_sync: PhantomData,
                },
                MDPDC: MDPDC {
                    _not_send_or_sync: PhantomData,
                },
                MDOTC: MDOTC {
                    _not_send_or_sync: PhantomData,
                },
                MDCFG0: MDCFG0 {
                    _not_send_or_sync: PhantomData,
                },
                MDCFG1: MDCFG1 {
                    _not_send_or_sync: PhantomData,
                },
                MDCFG2: MDCFG2 {
                    _not_send_or_sync: PhantomData,
                },
                MDMISC: MDMISC {
                    _not_send_or_sync: PhantomData,
                },
                MDSCR: MDSCR {
                    _not_send_or_sync: PhantomData,
                },
                MDREF: MDREF {
                    _not_send_or_sync: PhantomData,
                },
                MDRWD: MDRWD {
                    _not_send_or_sync: PhantomData,
                },
                MDOR: MDOR {
                    _not_send_or_sync: PhantomData,
                },
                MDMRR: MDMRR {
                    _not_send_or_sync: PhantomData,
                },
                MDCFG3LP: MDCFG3LP {
                    _not_send_or_sync: PhantomData,
                },
                MDMR4: MDMR4 {
                    _not_send_or_sync: PhantomData,
                },
                MDASP: MDASP {
                    _not_send_or_sync: PhantomData,
                },
                MAARCR: MAARCR {
                    _not_send_or_sync: PhantomData,
                },
                MAPSR: MAPSR {
                    _not_send_or_sync: PhantomData,
                },
                MAEXIDR0: MAEXIDR0 {
                    _not_send_or_sync: PhantomData,
                },
                MAEXIDR1: MAEXIDR1 {
                    _not_send_or_sync: PhantomData,
                },
                MADPCR0: MADPCR0 {
                    _not_send_or_sync: PhantomData,
                },
                MADPCR1: MADPCR1 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR0: MADPSR0 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR1: MADPSR1 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR2: MADPSR2 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR3: MADPSR3 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR4: MADPSR4 {
                    _not_send_or_sync: PhantomData,
                },
                MADPSR5: MADPSR5 {
                    _not_send_or_sync: PhantomData,
                },
                MASBS0: MASBS0 {
                    _not_send_or_sync: PhantomData,
                },
                MASBS1: MASBS1 {
                    _not_send_or_sync: PhantomData,
                },
                MAGENP: MAGENP {
                    _not_send_or_sync: PhantomData,
                },
                MPZQHWCTRL: MPZQHWCTRL {
                    _not_send_or_sync: PhantomData,
                },
                MPZQSWCTRL: MPZQSWCTRL {
                    _not_send_or_sync: PhantomData,
                },
                MPWLGCR: MPWLGCR {
                    _not_send_or_sync: PhantomData,
                },
                MPWLDECTRL0: MPWLDECTRL0 {
                    _not_send_or_sync: PhantomData,
                },
                MPWLDECTRL1: MPWLDECTRL1 {
                    _not_send_or_sync: PhantomData,
                },
                MPWLDLST: MPWLDLST {
                    _not_send_or_sync: PhantomData,
                },
                MPODTCTRL: MPODTCTRL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDQBY0DL: MPRDDQBY0DL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDQBY1DL: MPRDDQBY1DL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDQBY0DL: MPWRDQBY0DL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDQBY1DL: MPWRDQBY1DL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDQBY2DL: MPWRDQBY2DL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDQBY3DL: MPWRDQBY3DL {
                    _not_send_or_sync: PhantomData,
                },
                MPDGCTRL0: MPDGCTRL0 {
                    _not_send_or_sync: PhantomData,
                },
                MPDGDLST0: MPDGDLST0 {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDLCTL: MPRDDLCTL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDLST: MPRDDLST {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDLCTL: MPWRDLCTL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDLST: MPWRDLST {
                    _not_send_or_sync: PhantomData,
                },
                MPSDCTRL: MPSDCTRL {
                    _not_send_or_sync: PhantomData,
                },
                MPZQLP2CTL: MPZQLP2CTL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDLHWCTL: MPRDDLHWCTL {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDLHWCTL: MPWRDLHWCTL {
                    _not_send_or_sync: PhantomData,
                },
                MPRDDLHWST0: MPRDDLHWST0 {
                    _not_send_or_sync: PhantomData,
                },
                MPWRDLHWST0: MPWRDLHWST0 {
                    _not_send_or_sync: PhantomData,
                },
                MPWLHWERR: MPWLHWERR {
                    _not_send_or_sync: PhantomData,
                },
                MPDGHWST0: MPDGHWST0 {
                    _not_send_or_sync: PhantomData,
                },
                MPDGHWST1: MPDGHWST1 {
                    _not_send_or_sync: PhantomData,
                },
                MPPDCMPR1: MPPDCMPR1 {
                    _not_send_or_sync: PhantomData,
                },
                MPPDCMPR2: MPPDCMPR2 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDAR0: MPSWDAR0 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR0: MPSWDRDR0 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR1: MPSWDRDR1 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR2: MPSWDRDR2 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR3: MPSWDRDR3 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR4: MPSWDRDR4 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR5: MPSWDRDR5 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR6: MPSWDRDR6 {
                    _not_send_or_sync: PhantomData,
                },
                MPSWDRDR7: MPSWDRDR7 {
                    _not_send_or_sync: PhantomData,
                },
                MPMUR0: MPMUR0 {
                    _not_send_or_sync: PhantomData,
                },
                MPWRCADL: MPWRCADL {
                    _not_send_or_sync: PhantomData,
                },
                MPDCCR: MPDCCR {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "ccm")]
pub use ccm::CCM;
#[allow(non_snake_case)]
#[cfg(feature = "ccm")]
#[doc = "CCM"]
pub mod ccm {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x020c_4000;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "CCM Control Register"]
        pub CCR: CCR,
        #[doc = "CCM Control Divider Register"]
        pub CCDR: CCDR,
        #[doc = "CCM Status Register"]
        pub CSR: CSR,
        #[doc = "CCM Clock Switcher Register"]
        pub CCSR: CCSR,
        #[doc = "CCM Arm Clock Root Register"]
        pub CACRR: CACRR,
        #[doc = "CCM Bus Clock Divider Register"]
        pub CBCDR: CBCDR,
        #[doc = "CCM Bus Clock Multiplexer Register"]
        pub CBCMR: CBCMR,
        #[doc = "CCM Serial Clock Multiplexer Register 1"]
        pub CSCMR1: CSCMR1,
        #[doc = "CCM Serial Clock Multiplexer Register 2"]
        pub CSCMR2: CSCMR2,
        #[doc = "CCM Serial Clock Divider Register 1"]
        pub CSCDR1: CSCDR1,
        #[doc = "CCM SAI1 Clock Divider Register"]
        pub CS1CDR: CS1CDR,
        #[doc = "CCM SAI2 Clock Divider Register"]
        pub CS2CDR: CS2CDR,
        #[doc = "CCM D1 Clock Divider Register"]
        pub CDCDR: CDCDR,
        #[doc = "CCM HSC Clock Divider Register"]
        pub CHSCCDR: CHSCCDR,
        #[doc = "CCM Serial Clock Divider Register 2"]
        pub CSCDR2: CSCDR2,
        #[doc = "CCM Serial Clock Divider Register 3"]
        pub CSCDR3: CSCDR3,
        #[doc = "CCM Divider Handshake In-Process Register"]
        pub CDHIPR: CDHIPR,
        #[doc = "CCM Low Power Control Register"]
        pub CLPCR: CLPCR,
        #[doc = "CCM Interrupt Status Register"]
        pub CISR: CISR,
        #[doc = "CCM Interrupt Mask Register"]
        pub CIMR: CIMR,
        #[doc = "CCM Clock Output Source Register"]
        pub CCOSR: CCOSR,
        #[doc = "CCM General Purpose Register"]
        pub CGPR: CGPR,
        #[doc = "CCM Clock Gating Register 0"]
        pub CCGR0: CCGR0,
        #[doc = "CCM Clock Gating Register 1"]
        pub CCGR1: CCGR1,
        #[doc = "CCM Clock Gating Register 2"]
        pub CCGR2: CCGR2,
        #[doc = "CCM Clock Gating Register 3"]
        pub CCGR3: CCGR3,
        #[doc = "CCM Clock Gating Register 4"]
        pub CCGR4: CCGR4,
        #[doc = "CCM Clock Gating Register 5"]
        pub CCGR5: CCGR5,
        #[doc = "CCM Clock Gating Register 6"]
        pub CCGR6: CCGR6,
        #[doc = "CCM Module Enable Overide Register"]
        pub CMEOR: CMEOR,
    }
    unsafe impl Send for Registers {}
    #[doc = "CCM Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CCR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCR {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0401_167f;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Control Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct CCDR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCDR {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0002_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Status Register"]
    #[allow(non_camel_case_types)]
    pub struct CSR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSR {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0010;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Switcher Register"]
    #[allow(non_camel_case_types)]
    pub struct CCSR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCSR {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0100;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Arm Clock Root Register"]
    #[allow(non_camel_case_types)]
    pub struct CACRR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CACRR {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Bus Clock Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct CBCDR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CBCDR {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_8d00;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Bus Clock Multiplexer Register"]
    #[allow(non_camel_case_types)]
    pub struct CBCMR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CBCMR {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x2486_0324;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Serial Clock Multiplexer Register 1"]
    #[allow(non_camel_case_types)]
    pub struct CSCMR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSCMR1 {
        const OFFSET: usize = 0x1c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0490_0080;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Serial Clock Multiplexer Register 2"]
    #[allow(non_camel_case_types)]
    pub struct CSCMR2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSCMR2 {
        const OFFSET: usize = 0x20;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0319_2f06;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Serial Clock Divider Register 1"]
    #[allow(non_camel_case_types)]
    pub struct CSCDR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSCDR1 {
        const OFFSET: usize = 0x24;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0049_0b00;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM SAI1 Clock Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct CS1CDR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CS1CDR {
        const OFFSET: usize = 0x28;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0ec1_02c1;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM SAI2 Clock Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct CS2CDR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CS2CDR {
        const OFFSET: usize = 0x2c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0003_36c1;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM D1 Clock Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct CDCDR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CDCDR {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x33f7_1f92;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM HSC Clock Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct CHSCCDR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CHSCCDR {
        const OFFSET: usize = 0x34;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0002_9148;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Serial Clock Divider Register 2"]
    #[allow(non_camel_case_types)]
    pub struct CSCDR2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSCDR2 {
        const OFFSET: usize = 0x38;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0002_9b48;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Serial Clock Divider Register 3"]
    #[allow(non_camel_case_types)]
    pub struct CSCDR3 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSCDR3 {
        const OFFSET: usize = 0x3c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_4841;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Divider Handshake In-Process Register"]
    #[allow(non_camel_case_types)]
    pub struct CDHIPR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CDHIPR {
        const OFFSET: usize = 0x48;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Low Power Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CLPCR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CLPCR {
        const OFFSET: usize = 0x54;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0079;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Interrupt Status Register"]
    #[allow(non_camel_case_types)]
    pub struct CISR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CISR {
        const OFFSET: usize = 0x58;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn clear(&self, mask: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(mask) }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Interrupt Mask Register"]
    #[allow(non_camel_case_types)]
    pub struct CIMR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CIMR {
        const OFFSET: usize = 0x5c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Output Source Register"]
    #[allow(non_camel_case_types)]
    pub struct CCOSR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCOSR {
        const OFFSET: usize = 0x60;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x000a_0001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM General Purpose Register"]
    #[allow(non_camel_case_types)]
    pub struct CGPR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CGPR {
        const OFFSET: usize = 0x64;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_fe62;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Gating Register 0"]
    #[allow(non_camel_case_types)]
    pub struct CCGR0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCGR0 {
        const OFFSET: usize = 0x68;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Gating Register 1"]
    #[allow(non_camel_case_types)]
    pub struct CCGR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCGR1 {
        const OFFSET: usize = 0x6c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Gating Register 2"]
    #[allow(non_camel_case_types)]
    pub struct CCGR2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCGR2 {
        const OFFSET: usize = 0x70;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xfc3f_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Gating Register 3"]
    #[allow(non_camel_case_types)]
    pub struct CCGR3 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCGR3 {
        const OFFSET: usize = 0x74;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Gating Register 4"]
    #[allow(non_camel_case_types)]
    pub struct CCGR4 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCGR4 {
        const OFFSET: usize = 0x78;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Gating Register 5"]
    #[allow(non_camel_case_types)]
    pub struct CCGR5 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCGR5 {
        const OFFSET: usize = 0x7c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Clock Gating Register 6"]
    #[allow(non_camel_case_types)]
    pub struct CCGR6 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCGR6 {
        const OFFSET: usize = 0x80;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM Module Enable Overide Register"]
    #[allow(non_camel_case_types)]
    pub struct CMEOR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CMEOR {
        const OFFSET: usize = 0x88;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xffff_ffff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                CCR: CCR {
                    _not_send_or_sync: PhantomData,
                },
                CCDR: CCDR {
                    _not_send_or_sync: PhantomData,
                },
                CSR: CSR {
                    _not_send_or_sync: PhantomData,
                },
                CCSR: CCSR {
                    _not_send_or_sync: PhantomData,
                },
                CACRR: CACRR {
                    _not_send_or_sync: PhantomData,
                },
                CBCDR: CBCDR {
                    _not_send_or_sync: PhantomData,
                },
                CBCMR: CBCMR {
                    _not_send_or_sync: PhantomData,
                },
                CSCMR1: CSCMR1 {
                    _not_send_or_sync: PhantomData,
                },
                CSCMR2: CSCMR2 {
                    _not_send_or_sync: PhantomData,
                },
                CSCDR1: CSCDR1 {
                    _not_send_or_sync: PhantomData,
                },
                CS1CDR: CS1CDR {
                    _not_send_or_sync: PhantomData,
                },
                CS2CDR: CS2CDR {
                    _not_send_or_sync: PhantomData,
                },
                CDCDR: CDCDR {
                    _not_send_or_sync: PhantomData,
                },
                CHSCCDR: CHSCCDR {
                    _not_send_or_sync: PhantomData,
                },
                CSCDR2: CSCDR2 {
                    _not_send_or_sync: PhantomData,
                },
                CSCDR3: CSCDR3 {
                    _not_send_or_sync: PhantomData,
                },
                CDHIPR: CDHIPR {
                    _not_send_or_sync: PhantomData,
                },
                CLPCR: CLPCR {
                    _not_send_or_sync: PhantomData,
                },
                CISR: CISR {
                    _not_send_or_sync: PhantomData,
                },
                CIMR: CIMR {
                    _not_send_or_sync: PhantomData,
                },
                CCOSR: CCOSR {
                    _not_send_or_sync: PhantomData,
                },
                CGPR: CGPR {
                    _not_send_or_sync: PhantomData,
                },
                CCGR0: CCGR0 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR1: CCGR1 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR2: CCGR2 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR3: CCGR3 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR4: CCGR4 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR5: CCGR5 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR6: CCGR6 {
                    _not_send_or_sync: PhantomData,
                },
                CMEOR: CMEOR {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CCM"]
    pub type CCM = Registers;
    impl CCM {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                CCR: CCR {
                    _not_send_or_sync: PhantomData,
                },
                CCDR: CCDR {
                    _not_send_or_sync: PhantomData,
                },
                CSR: CSR {
                    _not_send_or_sync: PhantomData,
                },
                CCSR: CCSR {
                    _not_send_or_sync: PhantomData,
                },
                CACRR: CACRR {
                    _not_send_or_sync: PhantomData,
                },
                CBCDR: CBCDR {
                    _not_send_or_sync: PhantomData,
                },
                CBCMR: CBCMR {
                    _not_send_or_sync: PhantomData,
                },
                CSCMR1: CSCMR1 {
                    _not_send_or_sync: PhantomData,
                },
                CSCMR2: CSCMR2 {
                    _not_send_or_sync: PhantomData,
                },
                CSCDR1: CSCDR1 {
                    _not_send_or_sync: PhantomData,
                },
                CS1CDR: CS1CDR {
                    _not_send_or_sync: PhantomData,
                },
                CS2CDR: CS2CDR {
                    _not_send_or_sync: PhantomData,
                },
                CDCDR: CDCDR {
                    _not_send_or_sync: PhantomData,
                },
                CHSCCDR: CHSCCDR {
                    _not_send_or_sync: PhantomData,
                },
                CSCDR2: CSCDR2 {
                    _not_send_or_sync: PhantomData,
                },
                CSCDR3: CSCDR3 {
                    _not_send_or_sync: PhantomData,
                },
                CDHIPR: CDHIPR {
                    _not_send_or_sync: PhantomData,
                },
                CLPCR: CLPCR {
                    _not_send_or_sync: PhantomData,
                },
                CISR: CISR {
                    _not_send_or_sync: PhantomData,
                },
                CIMR: CIMR {
                    _not_send_or_sync: PhantomData,
                },
                CCOSR: CCOSR {
                    _not_send_or_sync: PhantomData,
                },
                CGPR: CGPR {
                    _not_send_or_sync: PhantomData,
                },
                CCGR0: CCGR0 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR1: CCGR1 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR2: CCGR2 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR3: CCGR3 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR4: CCGR4 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR5: CCGR5 {
                    _not_send_or_sync: PhantomData,
                },
                CCGR6: CCGR6 {
                    _not_send_or_sync: PhantomData,
                },
                CMEOR: CMEOR {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "hw_dcp")]
pub use hw_dcp::HW_DCP;
#[allow(non_snake_case)]
#[cfg(feature = "hw_dcp")]
#[doc = "HW_DCP"]
pub mod hw_dcp {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x0228_0000;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "DCP Control Register 0"]
        pub CTRL: CTRL,
        #[doc = "DCP Status Register"]
        pub STAT: STAT,
        #[doc = "DCP Channel Control Register"]
        pub CHANNELCTRL: CHANNELCTRL,
        #[doc = "DCP Channel Control Register"]
        pub CHANNELCTRL_SET: CHANNELCTRL_SET,
        #[doc = "DCP Channel Control Register"]
        pub CHANNELCTRL_CLR: CHANNELCTRL_CLR,
        #[doc = "DCP Capability 0 Register"]
        pub CAPABILITY0: CAPABILITY0,
        #[doc = "DCP Capability 1 Register"]
        pub CAPABILITY1: CAPABILITY1,
        #[doc = "DCP Context Buffer Pointer"]
        pub CONTEXT: CONTEXT,
        #[doc = "DCP Key Index"]
        pub KEY: KEY,
        #[doc = "DCP Key Data"]
        pub KEYDATA: KEYDATA,
        #[doc = "DCP Work Packet 0 Status Register"]
        pub PACKET0: PACKET0,
        #[doc = "DCP Work Packet 1 Status Register"]
        pub PACKET1: PACKET1,
        #[doc = "DCP Work Packet 2 Status Register"]
        pub PACKET2: PACKET2,
        #[doc = "DCP Work Packet 3 Status Register"]
        pub PACKET3: PACKET3,
        #[doc = "DCP Work Packet 4 Status Register"]
        pub PACKET4: PACKET4,
        #[doc = "DCP Work Packet 5 Status Register"]
        pub PACKET5: PACKET5,
        #[doc = "DCP Work Packet 6 Status Register"]
        pub PACKET6: PACKET6,
        #[doc = "DCP Channel 0 Command Pointer Address Register"]
        pub CH0CMDPTR: CH0CMDPTR,
        #[doc = "DCP Channel 0 Semaphore Register"]
        pub CH0SEMA: CH0SEMA,
        #[doc = "DCP Channel 0 Status Register"]
        pub CH0STAT: CH0STAT,
        #[doc = "DCP Channel 0 Options Register"]
        pub CH0OPTS: CH0OPTS,
        #[doc = "DCP Channel 1 Command Pointer Address Register"]
        pub CH1CMDPTR: CH1CMDPTR,
        #[doc = "DCP Channel 1 Semaphore Register"]
        pub CH1SEMA: CH1SEMA,
        #[doc = "DCP Channel 1 Status Register"]
        pub CH1STAT: CH1STAT,
        #[doc = "DCP Channel 1 Options Register"]
        pub CH1OPTS: CH1OPTS,
        #[doc = "DCP Channel 2 Command Pointer Address Register"]
        pub CH2CMDPTR: CH2CMDPTR,
        #[doc = "DCP Channel 2 Semaphore Register"]
        pub CH2SEMA: CH2SEMA,
        #[doc = "DCP Channel 2 Status Register"]
        pub CH2STAT: CH2STAT,
        #[doc = "DCP Channel 2 Options Register"]
        pub CH2OPTS: CH2OPTS,
        #[doc = "DCP Channel 3 Command Pointer Address Register"]
        pub CH3CMDPTR: CH3CMDPTR,
        #[doc = "DCP Channel 3 Semaphore Register"]
        pub CH3SEMA: CH3SEMA,
        #[doc = "DCP Channel 3 Status Register"]
        pub CH3STAT: CH3STAT,
        #[doc = "DCP Channel 3 Options Register"]
        pub CH3OPTS: CH3OPTS,
        #[doc = "DCP Debug Select Register"]
        pub DBGSELECT: DBGSELECT,
        #[doc = "DCP Debug Data Register"]
        pub DBGDATA: DBGDATA,
        #[doc = "DCP Page Table Register"]
        pub PAGETABLE: PAGETABLE,
        #[doc = "DCP Version Register"]
        pub VERSION: VERSION,
    }
    unsafe impl Send for Registers {}
    #[doc = "DCP Control Register 0"]
    #[allow(non_camel_case_types)]
    pub struct CTRL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CTRL {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xf080_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Status Register"]
    #[allow(non_camel_case_types)]
    pub struct STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl STAT {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CHANNELCTRL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CHANNELCTRL {
        const OFFSET: usize = 0x20;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CHANNELCTRL_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CHANNELCTRL_SET {
        const OFFSET: usize = 0x24;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CHANNELCTRL_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CHANNELCTRL_CLR {
        const OFFSET: usize = 0x28;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Capability 0 Register"]
    #[allow(non_camel_case_types)]
    pub struct CAPABILITY0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CAPABILITY0 {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0404;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Capability 1 Register"]
    #[allow(non_camel_case_types)]
    pub struct CAPABILITY1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CAPABILITY1 {
        const OFFSET: usize = 0x40;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0007_0001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Context Buffer Pointer"]
    #[allow(non_camel_case_types)]
    pub struct CONTEXT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CONTEXT {
        const OFFSET: usize = 0x50;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Key Index"]
    #[allow(non_camel_case_types)]
    pub struct KEY {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl KEY {
        const OFFSET: usize = 0x60;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Key Data"]
    #[allow(non_camel_case_types)]
    pub struct KEYDATA {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl KEYDATA {
        const OFFSET: usize = 0x70;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Work Packet 0 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct PACKET0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PACKET0 {
        const OFFSET: usize = 0x80;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Work Packet 1 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct PACKET1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PACKET1 {
        const OFFSET: usize = 0x90;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Work Packet 2 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct PACKET2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PACKET2 {
        const OFFSET: usize = 0xa0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Work Packet 3 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct PACKET3 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PACKET3 {
        const OFFSET: usize = 0xb0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Work Packet 4 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct PACKET4 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PACKET4 {
        const OFFSET: usize = 0xc0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Work Packet 5 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct PACKET5 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PACKET5 {
        const OFFSET: usize = 0xd0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Work Packet 6 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct PACKET6 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PACKET6 {
        const OFFSET: usize = 0xe0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 0 Command Pointer Address Register"]
    #[allow(non_camel_case_types)]
    pub struct CH0CMDPTR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH0CMDPTR {
        const OFFSET: usize = 0x0100;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 0 Semaphore Register"]
    #[allow(non_camel_case_types)]
    pub struct CH0SEMA {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH0SEMA {
        const OFFSET: usize = 0x0110;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 0 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct CH0STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH0STAT {
        const OFFSET: usize = 0x0120;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 0 Options Register"]
    #[allow(non_camel_case_types)]
    pub struct CH0OPTS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH0OPTS {
        const OFFSET: usize = 0x0130;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 1 Command Pointer Address Register"]
    #[allow(non_camel_case_types)]
    pub struct CH1CMDPTR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH1CMDPTR {
        const OFFSET: usize = 0x0140;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 1 Semaphore Register"]
    #[allow(non_camel_case_types)]
    pub struct CH1SEMA {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH1SEMA {
        const OFFSET: usize = 0x0150;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 1 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct CH1STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH1STAT {
        const OFFSET: usize = 0x0160;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 1 Options Register"]
    #[allow(non_camel_case_types)]
    pub struct CH1OPTS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH1OPTS {
        const OFFSET: usize = 0x0170;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 2 Command Pointer Address Register"]
    #[allow(non_camel_case_types)]
    pub struct CH2CMDPTR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH2CMDPTR {
        const OFFSET: usize = 0x0180;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 2 Semaphore Register"]
    #[allow(non_camel_case_types)]
    pub struct CH2SEMA {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH2SEMA {
        const OFFSET: usize = 0x0190;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 2 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct CH2STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH2STAT {
        const OFFSET: usize = 0x01a0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 2 Options Register"]
    #[allow(non_camel_case_types)]
    pub struct CH2OPTS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH2OPTS {
        const OFFSET: usize = 0x01b0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 3 Command Pointer Address Register"]
    #[allow(non_camel_case_types)]
    pub struct CH3CMDPTR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH3CMDPTR {
        const OFFSET: usize = 0x01c0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 3 Semaphore Register"]
    #[allow(non_camel_case_types)]
    pub struct CH3SEMA {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH3SEMA {
        const OFFSET: usize = 0x01d0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 3 Status Register"]
    #[allow(non_camel_case_types)]
    pub struct CH3STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH3STAT {
        const OFFSET: usize = 0x01e0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Channel 3 Options Register"]
    #[allow(non_camel_case_types)]
    pub struct CH3OPTS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CH3OPTS {
        const OFFSET: usize = 0x01f0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Debug Select Register"]
    #[allow(non_camel_case_types)]
    pub struct DBGSELECT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl DBGSELECT {
        const OFFSET: usize = 0x0400;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Debug Data Register"]
    #[allow(non_camel_case_types)]
    pub struct DBGDATA {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl DBGDATA {
        const OFFSET: usize = 0x0410;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Page Table Register"]
    #[allow(non_camel_case_types)]
    pub struct PAGETABLE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PAGETABLE {
        const OFFSET: usize = 0x0420;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "DCP Version Register"]
    #[allow(non_camel_case_types)]
    pub struct VERSION {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl VERSION {
        const OFFSET: usize = 0x0430;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0201_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                CTRL: CTRL {
                    _not_send_or_sync: PhantomData,
                },
                STAT: STAT {
                    _not_send_or_sync: PhantomData,
                },
                CHANNELCTRL: CHANNELCTRL {
                    _not_send_or_sync: PhantomData,
                },
                CHANNELCTRL_SET: CHANNELCTRL_SET {
                    _not_send_or_sync: PhantomData,
                },
                CHANNELCTRL_CLR: CHANNELCTRL_CLR {
                    _not_send_or_sync: PhantomData,
                },
                CAPABILITY0: CAPABILITY0 {
                    _not_send_or_sync: PhantomData,
                },
                CAPABILITY1: CAPABILITY1 {
                    _not_send_or_sync: PhantomData,
                },
                CONTEXT: CONTEXT {
                    _not_send_or_sync: PhantomData,
                },
                KEY: KEY {
                    _not_send_or_sync: PhantomData,
                },
                KEYDATA: KEYDATA {
                    _not_send_or_sync: PhantomData,
                },
                PACKET0: PACKET0 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET1: PACKET1 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET2: PACKET2 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET3: PACKET3 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET4: PACKET4 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET5: PACKET5 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET6: PACKET6 {
                    _not_send_or_sync: PhantomData,
                },
                CH0CMDPTR: CH0CMDPTR {
                    _not_send_or_sync: PhantomData,
                },
                CH0SEMA: CH0SEMA {
                    _not_send_or_sync: PhantomData,
                },
                CH0STAT: CH0STAT {
                    _not_send_or_sync: PhantomData,
                },
                CH0OPTS: CH0OPTS {
                    _not_send_or_sync: PhantomData,
                },
                CH1CMDPTR: CH1CMDPTR {
                    _not_send_or_sync: PhantomData,
                },
                CH1SEMA: CH1SEMA {
                    _not_send_or_sync: PhantomData,
                },
                CH1STAT: CH1STAT {
                    _not_send_or_sync: PhantomData,
                },
                CH1OPTS: CH1OPTS {
                    _not_send_or_sync: PhantomData,
                },
                CH2CMDPTR: CH2CMDPTR {
                    _not_send_or_sync: PhantomData,
                },
                CH2SEMA: CH2SEMA {
                    _not_send_or_sync: PhantomData,
                },
                CH2STAT: CH2STAT {
                    _not_send_or_sync: PhantomData,
                },
                CH2OPTS: CH2OPTS {
                    _not_send_or_sync: PhantomData,
                },
                CH3CMDPTR: CH3CMDPTR {
                    _not_send_or_sync: PhantomData,
                },
                CH3SEMA: CH3SEMA {
                    _not_send_or_sync: PhantomData,
                },
                CH3STAT: CH3STAT {
                    _not_send_or_sync: PhantomData,
                },
                CH3OPTS: CH3OPTS {
                    _not_send_or_sync: PhantomData,
                },
                DBGSELECT: DBGSELECT {
                    _not_send_or_sync: PhantomData,
                },
                DBGDATA: DBGDATA {
                    _not_send_or_sync: PhantomData,
                },
                PAGETABLE: PAGETABLE {
                    _not_send_or_sync: PhantomData,
                },
                VERSION: VERSION {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "HW_DCP"]
    pub type HW_DCP = Registers;
    impl HW_DCP {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                CTRL: CTRL {
                    _not_send_or_sync: PhantomData,
                },
                STAT: STAT {
                    _not_send_or_sync: PhantomData,
                },
                CHANNELCTRL: CHANNELCTRL {
                    _not_send_or_sync: PhantomData,
                },
                CHANNELCTRL_SET: CHANNELCTRL_SET {
                    _not_send_or_sync: PhantomData,
                },
                CHANNELCTRL_CLR: CHANNELCTRL_CLR {
                    _not_send_or_sync: PhantomData,
                },
                CAPABILITY0: CAPABILITY0 {
                    _not_send_or_sync: PhantomData,
                },
                CAPABILITY1: CAPABILITY1 {
                    _not_send_or_sync: PhantomData,
                },
                CONTEXT: CONTEXT {
                    _not_send_or_sync: PhantomData,
                },
                KEY: KEY {
                    _not_send_or_sync: PhantomData,
                },
                KEYDATA: KEYDATA {
                    _not_send_or_sync: PhantomData,
                },
                PACKET0: PACKET0 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET1: PACKET1 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET2: PACKET2 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET3: PACKET3 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET4: PACKET4 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET5: PACKET5 {
                    _not_send_or_sync: PhantomData,
                },
                PACKET6: PACKET6 {
                    _not_send_or_sync: PhantomData,
                },
                CH0CMDPTR: CH0CMDPTR {
                    _not_send_or_sync: PhantomData,
                },
                CH0SEMA: CH0SEMA {
                    _not_send_or_sync: PhantomData,
                },
                CH0STAT: CH0STAT {
                    _not_send_or_sync: PhantomData,
                },
                CH0OPTS: CH0OPTS {
                    _not_send_or_sync: PhantomData,
                },
                CH1CMDPTR: CH1CMDPTR {
                    _not_send_or_sync: PhantomData,
                },
                CH1SEMA: CH1SEMA {
                    _not_send_or_sync: PhantomData,
                },
                CH1STAT: CH1STAT {
                    _not_send_or_sync: PhantomData,
                },
                CH1OPTS: CH1OPTS {
                    _not_send_or_sync: PhantomData,
                },
                CH2CMDPTR: CH2CMDPTR {
                    _not_send_or_sync: PhantomData,
                },
                CH2SEMA: CH2SEMA {
                    _not_send_or_sync: PhantomData,
                },
                CH2STAT: CH2STAT {
                    _not_send_or_sync: PhantomData,
                },
                CH2OPTS: CH2OPTS {
                    _not_send_or_sync: PhantomData,
                },
                CH3CMDPTR: CH3CMDPTR {
                    _not_send_or_sync: PhantomData,
                },
                CH3SEMA: CH3SEMA {
                    _not_send_or_sync: PhantomData,
                },
                CH3STAT: CH3STAT {
                    _not_send_or_sync: PhantomData,
                },
                CH3OPTS: CH3OPTS {
                    _not_send_or_sync: PhantomData,
                },
                DBGSELECT: DBGSELECT {
                    _not_send_or_sync: PhantomData,
                },
                DBGDATA: DBGDATA {
                    _not_send_or_sync: PhantomData,
                },
                PAGETABLE: PAGETABLE {
                    _not_send_or_sync: PhantomData,
                },
                VERSION: VERSION {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "gpio")]
pub use gpio::GPIO1;
#[cfg(feature = "gpio")]
pub use gpio::GPIO2;
#[cfg(feature = "gpio")]
pub use gpio::GPIO3;
#[cfg(feature = "gpio")]
pub use gpio::GPIO4;
#[cfg(feature = "gpio")]
pub use gpio::GPIO5;
#[allow(non_snake_case)]
#[cfg(feature = "gpio")]
#[doc = "GPIO"]
pub mod gpio {
    use crate::Peripheral;
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_sync: PhantomData<*mut ()>,
        #[doc = "GPIO data register"]
        pub DR: DR<P>,
        #[doc = "GPIO direction register"]
        pub GDIR: GDIR<P>,
        #[doc = "GPIO pad status register"]
        pub PSR: PSR<P>,
        #[doc = "GPIO interrupt configuration register1"]
        pub ICR1: ICR1<P>,
        #[doc = "GPIO interrupt configuration register2"]
        pub ICR2: ICR2<P>,
        #[doc = "GPIO interrupt mask register"]
        pub IMR: IMR<P>,
        #[doc = "GPIO interrupt status register"]
        pub ISR: ISR<P>,
        #[doc = "GPIO edge select register"]
        pub EDGE_SEL: EDGE_SEL<P>,
    }
    unsafe impl<P> Send for Registers<P> where P: Peripheral {}
    #[doc = "GPIO data register"]
    #[allow(non_camel_case_types)]
    pub struct DR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "GPIO direction register"]
    #[allow(non_camel_case_types)]
    pub struct GDIR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> GDIR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "GPIO pad status register"]
    #[allow(non_camel_case_types)]
    pub struct PSR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PSR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "GPIO interrupt configuration register1"]
    #[allow(non_camel_case_types)]
    pub struct ICR1<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ICR1<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "GPIO interrupt configuration register2"]
    #[allow(non_camel_case_types)]
    pub struct ICR2<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ICR2<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "GPIO interrupt mask register"]
    #[allow(non_camel_case_types)]
    pub struct IMR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> IMR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "GPIO interrupt status register"]
    #[allow(non_camel_case_types)]
    pub struct ISR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ISR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn clear(&self, mask: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(mask) }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "GPIO edge select register"]
    #[allow(non_camel_case_types)]
    pub struct EDGE_SEL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> EDGE_SEL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x1c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    impl<P> Registers<P>
    where
        P: Peripheral,
    {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _p: PhantomData,
                _not_sync: PhantomData,
                DR: DR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                GDIR: GDIR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                PSR: PSR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ICR1: ICR1 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ICR2: ICR2 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                IMR: IMR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ISR: ISR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                EDGE_SEL: EDGE_SEL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[doc = "GPIO1"]
    pub struct _1;
    impl Peripheral for _1 {
        const BASE_ADDRESS: usize = 0x0209_c000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "GPIO1"]
    pub type GPIO1 = Registers<_1>;
    impl GPIO1 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "GPIO2"]
    pub struct _2;
    impl Peripheral for _2 {
        const BASE_ADDRESS: usize = 0x020a_0000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "GPIO2"]
    pub type GPIO2 = Registers<_2>;
    impl GPIO2 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "GPIO3"]
    pub struct _3;
    impl Peripheral for _3 {
        const BASE_ADDRESS: usize = 0x020a_4000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "GPIO3"]
    pub type GPIO3 = Registers<_3>;
    impl GPIO3 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "GPIO4"]
    pub struct _4;
    impl Peripheral for _4 {
        const BASE_ADDRESS: usize = 0x020a_8000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "GPIO4"]
    pub type GPIO4 = Registers<_4>;
    impl GPIO4 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "GPIO5"]
    pub struct _5;
    impl Peripheral for _5 {
        const BASE_ADDRESS: usize = 0x020a_c000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "GPIO5"]
    pub type GPIO5 = Registers<_5>;
    impl GPIO5 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
}
#[cfg(feature = "i2c")]
pub use i2c::I2C1;
#[cfg(feature = "i2c")]
pub use i2c::I2C2;
#[cfg(feature = "i2c")]
pub use i2c::I2C3;
#[cfg(feature = "i2c")]
pub use i2c::I2C4;
#[allow(non_snake_case)]
#[cfg(feature = "i2c")]
#[doc = "I2C"]
pub mod i2c {
    use crate::Peripheral;
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_sync: PhantomData<*mut ()>,
        #[doc = "I2C Address Register"]
        pub IADR: IADR<P>,
        #[doc = "I2C Frequency Divider Register"]
        pub IFDR: IFDR<P>,
        #[doc = "I2C Control Register"]
        pub I2CR: I2CR<P>,
        #[doc = "I2C Status Register"]
        pub I2SR: I2SR<P>,
        #[doc = "I2C Data I/O Register"]
        pub I2DR: I2DR<P>,
    }
    unsafe impl<P> Send for Registers<P> where P: Peripheral {}
    #[doc = "I2C Address Register"]
    #[allow(non_camel_case_types)]
    pub struct IADR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> IADR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "I2C Frequency Divider Register"]
    #[allow(non_camel_case_types)]
    pub struct IFDR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> IFDR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "I2C Control Register"]
    #[allow(non_camel_case_types)]
    pub struct I2CR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> I2CR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "I2C Status Register"]
    #[allow(non_camel_case_types)]
    pub struct I2SR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> I2SR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0081;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "I2C Data I/O Register"]
    #[allow(non_camel_case_types)]
    pub struct I2DR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> I2DR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    impl<P> Registers<P>
    where
        P: Peripheral,
    {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _p: PhantomData,
                _not_sync: PhantomData,
                IADR: IADR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                IFDR: IFDR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                I2CR: I2CR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                I2SR: I2SR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                I2DR: I2DR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[doc = "I2C1"]
    pub struct _1;
    impl Peripheral for _1 {
        const BASE_ADDRESS: usize = 0x021a_0000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "I2C1"]
    pub type I2C1 = Registers<_1>;
    impl I2C1 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "I2C2"]
    pub struct _2;
    impl Peripheral for _2 {
        const BASE_ADDRESS: usize = 0x021a_4000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "I2C2"]
    pub type I2C2 = Registers<_2>;
    impl I2C2 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "I2C3"]
    pub struct _3;
    impl Peripheral for _3 {
        const BASE_ADDRESS: usize = 0x021a_8000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "I2C3"]
    pub type I2C3 = Registers<_3>;
    impl I2C3 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "I2C4"]
    pub struct _4;
    impl Peripheral for _4 {
        const BASE_ADDRESS: usize = 0x021f_8000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "I2C4"]
    pub type I2C4 = Registers<_4>;
    impl I2C4 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
}
#[cfg(feature = "iomuxc")]
pub use iomuxc::IOMUXC;
#[allow(non_snake_case)]
#[cfg(feature = "iomuxc")]
#[doc = "IOMUXC"]
pub mod iomuxc {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x020e_0014;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "SW_MUX_CTL_PAD_BOOT_MODE0 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_BOOT_MODE0: SW_MUX_CTL_PAD_BOOT_MODE0,
        #[doc = "SW_MUX_CTL_PAD_BOOT_MODE1 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_BOOT_MODE1: SW_MUX_CTL_PAD_BOOT_MODE1,
        #[doc = "SW_MUX_CTL_PAD_JTAG_MOD SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_JTAG_MOD: SW_MUX_CTL_PAD_JTAG_MOD,
        #[doc = "SW_MUX_CTL_PAD_JTAG_TMS SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_JTAG_TMS: SW_MUX_CTL_PAD_JTAG_TMS,
        #[doc = "SW_MUX_CTL_PAD_JTAG_TDO SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_JTAG_TDO: SW_MUX_CTL_PAD_JTAG_TDO,
        #[doc = "SW_MUX_CTL_PAD_JTAG_TDI SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_JTAG_TDI: SW_MUX_CTL_PAD_JTAG_TDI,
        #[doc = "SW_MUX_CTL_PAD_JTAG_TCK SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_JTAG_TCK: SW_MUX_CTL_PAD_JTAG_TCK,
        #[doc = "SW_MUX_CTL_PAD_JTAG_TRST_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_JTAG_TRST_B: SW_MUX_CTL_PAD_JTAG_TRST_B,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO00 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO00: SW_MUX_CTL_PAD_GPIO1_IO00,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO01 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO01: SW_MUX_CTL_PAD_GPIO1_IO01,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO02 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO02: SW_MUX_CTL_PAD_GPIO1_IO02,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO03 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO03: SW_MUX_CTL_PAD_GPIO1_IO03,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO04 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO04: SW_MUX_CTL_PAD_GPIO1_IO04,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO05 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO05: SW_MUX_CTL_PAD_GPIO1_IO05,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO06 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO06: SW_MUX_CTL_PAD_GPIO1_IO06,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO07 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO07: SW_MUX_CTL_PAD_GPIO1_IO07,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO08 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO08: SW_MUX_CTL_PAD_GPIO1_IO08,
        #[doc = "SW_MUX_CTL_PAD_GPIO1_IO09 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_GPIO1_IO09: SW_MUX_CTL_PAD_GPIO1_IO09,
        #[doc = "SW_MUX_CTL_PAD_UART1_CTS_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_UART1_CTS_B: SW_MUX_CTL_PAD_UART1_CTS_B,
        #[doc = "SW_MUX_CTL_PAD_UART1_RTS_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_UART1_RTS_B: SW_MUX_CTL_PAD_UART1_RTS_B,
        #[doc = "SW_MUX_CTL_PAD_UART2_CTS_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_UART2_CTS_B: SW_MUX_CTL_PAD_UART2_CTS_B,
        #[doc = "SW_MUX_CTL_PAD_UART2_RTS_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_UART2_RTS_B: SW_MUX_CTL_PAD_UART2_RTS_B,
        #[doc = "SW_MUX_CTL_PAD_UART3_CTS_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_UART3_CTS_B: SW_MUX_CTL_PAD_UART3_CTS_B,
        #[doc = "SW_MUX_CTL_PAD_UART3_RTS_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_UART3_RTS_B: SW_MUX_CTL_PAD_UART3_RTS_B,
        #[doc = "SW_MUX_CTL_PAD_ENET1_RX_EN SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_ENET1_RX_EN: SW_MUX_CTL_PAD_ENET1_RX_EN,
        #[doc = "SW_MUX_CTL_PAD_ENET1_TX_EN SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_ENET1_TX_EN: SW_MUX_CTL_PAD_ENET1_TX_EN,
        #[doc = "SW_MUX_CTL_PAD_ENET1_TX_CLK SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_ENET1_TX_CLK: SW_MUX_CTL_PAD_ENET1_TX_CLK,
        #[doc = "SW_MUX_CTL_PAD_ENET1_RX_ER SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_ENET1_RX_ER: SW_MUX_CTL_PAD_ENET1_RX_ER,
        #[doc = "SW_MUX_CTL_PAD_ENET2_RX_EN SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_ENET2_RX_EN: SW_MUX_CTL_PAD_ENET2_RX_EN,
        #[doc = "SW_MUX_CTL_PAD_ENET2_TX_EN SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_ENET2_TX_EN: SW_MUX_CTL_PAD_ENET2_TX_EN,
        #[doc = "SW_MUX_CTL_PAD_ENET2_TX_CLK SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_ENET2_TX_CLK: SW_MUX_CTL_PAD_ENET2_TX_CLK,
        #[doc = "SW_MUX_CTL_PAD_ENET2_RX_ER SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_ENET2_RX_ER: SW_MUX_CTL_PAD_ENET2_RX_ER,
        #[doc = "SW_MUX_CTL_PAD_LCD_CLK SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_CLK: SW_MUX_CTL_PAD_LCD_CLK,
        #[doc = "SW_MUX_CTL_PAD_LCD_ENABLE SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_ENABLE: SW_MUX_CTL_PAD_LCD_ENABLE,
        #[doc = "SW_MUX_CTL_PAD_LCD_HSYNC SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_HSYNC: SW_MUX_CTL_PAD_LCD_HSYNC,
        #[doc = "SW_MUX_CTL_PAD_LCD_VSYNC SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_VSYNC: SW_MUX_CTL_PAD_LCD_VSYNC,
        #[doc = "SW_MUX_CTL_PAD_LCD_RESET SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_RESET: SW_MUX_CTL_PAD_LCD_RESET,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA00 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA00: SW_MUX_CTL_PAD_LCD_DATA00,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA01 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA01: SW_MUX_CTL_PAD_LCD_DATA01,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA02 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA02: SW_MUX_CTL_PAD_LCD_DATA02,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA03 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA03: SW_MUX_CTL_PAD_LCD_DATA03,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA04 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA04: SW_MUX_CTL_PAD_LCD_DATA04,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA05 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA05: SW_MUX_CTL_PAD_LCD_DATA05,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA06 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA06: SW_MUX_CTL_PAD_LCD_DATA06,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA07 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA07: SW_MUX_CTL_PAD_LCD_DATA07,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA08 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA08: SW_MUX_CTL_PAD_LCD_DATA08,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA09 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA09: SW_MUX_CTL_PAD_LCD_DATA09,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA10 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA10: SW_MUX_CTL_PAD_LCD_DATA10,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA11 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA11: SW_MUX_CTL_PAD_LCD_DATA11,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA12 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA12: SW_MUX_CTL_PAD_LCD_DATA12,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA13 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA13: SW_MUX_CTL_PAD_LCD_DATA13,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA14 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA14: SW_MUX_CTL_PAD_LCD_DATA14,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA15 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA15: SW_MUX_CTL_PAD_LCD_DATA15,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA16 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA16: SW_MUX_CTL_PAD_LCD_DATA16,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA17 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA17: SW_MUX_CTL_PAD_LCD_DATA17,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA18 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA18: SW_MUX_CTL_PAD_LCD_DATA18,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA19 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA19: SW_MUX_CTL_PAD_LCD_DATA19,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA20 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA20: SW_MUX_CTL_PAD_LCD_DATA20,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA21 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA21: SW_MUX_CTL_PAD_LCD_DATA21,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA22 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA22: SW_MUX_CTL_PAD_LCD_DATA22,
        #[doc = "SW_MUX_CTL_PAD_LCD_DATA23 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_LCD_DATA23: SW_MUX_CTL_PAD_LCD_DATA23,
        #[doc = "SW_MUX_CTL_PAD_NAND_RE_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_RE_B: SW_MUX_CTL_PAD_NAND_RE_B,
        #[doc = "SW_MUX_CTL_PAD_NAND_WE_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_WE_B: SW_MUX_CTL_PAD_NAND_WE_B,
        #[doc = "SW_MUX_CTL_PAD_NAND_DATA00 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DATA00: SW_MUX_CTL_PAD_NAND_DATA00,
        #[doc = "SW_MUX_CTL_PAD_NAND_DATA01 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DATA01: SW_MUX_CTL_PAD_NAND_DATA01,
        #[doc = "SW_MUX_CTL_PAD_NAND_DATA02 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DATA02: SW_MUX_CTL_PAD_NAND_DATA02,
        #[doc = "SW_MUX_CTL_PAD_NAND_DATA03 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DATA03: SW_MUX_CTL_PAD_NAND_DATA03,
        #[doc = "SW_MUX_CTL_PAD_NAND_DATA04 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DATA04: SW_MUX_CTL_PAD_NAND_DATA04,
        #[doc = "SW_MUX_CTL_PAD_NAND_DATA05 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DATA05: SW_MUX_CTL_PAD_NAND_DATA05,
        #[doc = "SW_MUX_CTL_PAD_NAND_DATA06 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DATA06: SW_MUX_CTL_PAD_NAND_DATA06,
        #[doc = "SW_MUX_CTL_PAD_NAND_DATA07 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DATA07: SW_MUX_CTL_PAD_NAND_DATA07,
        #[doc = "SW_MUX_CTL_PAD_NAND_ALE SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_ALE: SW_MUX_CTL_PAD_NAND_ALE,
        #[doc = "SW_MUX_CTL_PAD_NAND_WP_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_WP_B: SW_MUX_CTL_PAD_NAND_WP_B,
        #[doc = "SW_MUX_CTL_PAD_NAND_CE0_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_CE0_B: SW_MUX_CTL_PAD_NAND_CE0_B,
        #[doc = "SW_MUX_CTL_PAD_NAND_CE1_B SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_CE1_B: SW_MUX_CTL_PAD_NAND_CE1_B,
        #[doc = "SW_MUX_CTL_PAD_NAND_CLE SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_CLE: SW_MUX_CTL_PAD_NAND_CLE,
        #[doc = "SW_MUX_CTL_PAD_NAND_DQS SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_NAND_DQS: SW_MUX_CTL_PAD_NAND_DQS,
        #[doc = "SW_MUX_CTL_PAD_SD1_CMD SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_SD1_CMD: SW_MUX_CTL_PAD_SD1_CMD,
        #[doc = "SW_MUX_CTL_PAD_SD1_CLK SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_SD1_CLK: SW_MUX_CTL_PAD_SD1_CLK,
        #[doc = "SW_MUX_CTL_PAD_SD1_DATA0 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_SD1_DATA0: SW_MUX_CTL_PAD_SD1_DATA0,
        #[doc = "SW_MUX_CTL_PAD_SD1_DATA1 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_SD1_DATA1: SW_MUX_CTL_PAD_SD1_DATA1,
        #[doc = "SW_MUX_CTL_PAD_SD1_DATA2 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_SD1_DATA2: SW_MUX_CTL_PAD_SD1_DATA2,
        #[doc = "SW_MUX_CTL_PAD_SD1_DATA3 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_SD1_DATA3: SW_MUX_CTL_PAD_SD1_DATA3,
        #[doc = "SW_MUX_CTL_PAD_CSI_MCLK SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_MCLK: SW_MUX_CTL_PAD_CSI_MCLK,
        #[doc = "SW_MUX_CTL_PAD_CSI_PIXCLK SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_PIXCLK: SW_MUX_CTL_PAD_CSI_PIXCLK,
        #[doc = "SW_MUX_CTL_PAD_CSI_VSYNC SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_VSYNC: SW_MUX_CTL_PAD_CSI_VSYNC,
        #[doc = "SW_MUX_CTL_PAD_CSI_HSYNC SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_HSYNC: SW_MUX_CTL_PAD_CSI_HSYNC,
        #[doc = "SW_MUX_CTL_PAD_CSI_DATA00 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_DATA00: SW_MUX_CTL_PAD_CSI_DATA00,
        #[doc = "SW_MUX_CTL_PAD_CSI_DATA01 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_DATA01: SW_MUX_CTL_PAD_CSI_DATA01,
        #[doc = "SW_MUX_CTL_PAD_CSI_DATA02 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_DATA02: SW_MUX_CTL_PAD_CSI_DATA02,
        #[doc = "SW_MUX_CTL_PAD_CSI_DATA03 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_DATA03: SW_MUX_CTL_PAD_CSI_DATA03,
        #[doc = "SW_MUX_CTL_PAD_CSI_DATA04 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_DATA04: SW_MUX_CTL_PAD_CSI_DATA04,
        #[doc = "SW_MUX_CTL_PAD_CSI_DATA05 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_DATA05: SW_MUX_CTL_PAD_CSI_DATA05,
        #[doc = "SW_MUX_CTL_PAD_CSI_DATA06 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_DATA06: SW_MUX_CTL_PAD_CSI_DATA06,
        #[doc = "SW_MUX_CTL_PAD_CSI_DATA07 SW MUX Control Register"]
        pub SW_MUX_CTL_PAD_CSI_DATA07: SW_MUX_CTL_PAD_CSI_DATA07,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR00 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR00: SW_PAD_CTL_PAD_DRAM_ADDR00,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR01 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR01: SW_PAD_CTL_PAD_DRAM_ADDR01,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR02 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR02: SW_PAD_CTL_PAD_DRAM_ADDR02,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR03 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR03: SW_PAD_CTL_PAD_DRAM_ADDR03,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR04 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR04: SW_PAD_CTL_PAD_DRAM_ADDR04,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR05 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR05: SW_PAD_CTL_PAD_DRAM_ADDR05,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR06 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR06: SW_PAD_CTL_PAD_DRAM_ADDR06,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR07 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR07: SW_PAD_CTL_PAD_DRAM_ADDR07,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR08 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR08: SW_PAD_CTL_PAD_DRAM_ADDR08,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR09 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR09: SW_PAD_CTL_PAD_DRAM_ADDR09,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR10 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR10: SW_PAD_CTL_PAD_DRAM_ADDR10,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR11 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR11: SW_PAD_CTL_PAD_DRAM_ADDR11,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR12 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR12: SW_PAD_CTL_PAD_DRAM_ADDR12,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR13 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR13: SW_PAD_CTL_PAD_DRAM_ADDR13,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR14 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR14: SW_PAD_CTL_PAD_DRAM_ADDR14,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR15 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ADDR15: SW_PAD_CTL_PAD_DRAM_ADDR15,
        #[doc = "SW_PAD_CTL_PAD_DRAM_DQM0 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_DQM0: SW_PAD_CTL_PAD_DRAM_DQM0,
        #[doc = "SW_PAD_CTL_PAD_DRAM_DQM1 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_DQM1: SW_PAD_CTL_PAD_DRAM_DQM1,
        #[doc = "SW_PAD_CTL_PAD_DRAM_RAS_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_RAS_B: SW_PAD_CTL_PAD_DRAM_RAS_B,
        #[doc = "SW_PAD_CTL_PAD_DRAM_CAS_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_CAS_B: SW_PAD_CTL_PAD_DRAM_CAS_B,
        #[doc = "SW_PAD_CTL_PAD_DRAM_CS0_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_CS0_B: SW_PAD_CTL_PAD_DRAM_CS0_B,
        #[doc = "SW_PAD_CTL_PAD_DRAM_CS1_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_CS1_B: SW_PAD_CTL_PAD_DRAM_CS1_B,
        #[doc = "SW_PAD_CTL_PAD_DRAM_SDWE_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_SDWE_B: SW_PAD_CTL_PAD_DRAM_SDWE_B,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ODT0 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ODT0: SW_PAD_CTL_PAD_DRAM_ODT0,
        #[doc = "SW_PAD_CTL_PAD_DRAM_ODT1 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_ODT1: SW_PAD_CTL_PAD_DRAM_ODT1,
        #[doc = "SW_PAD_CTL_PAD_DRAM_SDBA0 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_SDBA0: SW_PAD_CTL_PAD_DRAM_SDBA0,
        #[doc = "SW_PAD_CTL_PAD_DRAM_SDBA1 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_SDBA1: SW_PAD_CTL_PAD_DRAM_SDBA1,
        #[doc = "SW_PAD_CTL_PAD_DRAM_SDBA2 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_SDBA2: SW_PAD_CTL_PAD_DRAM_SDBA2,
        #[doc = "SW_PAD_CTL_PAD_DRAM_SDCKE0 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_SDCKE0: SW_PAD_CTL_PAD_DRAM_SDCKE0,
        #[doc = "SW_PAD_CTL_PAD_DRAM_SDCKE1 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_SDCKE1: SW_PAD_CTL_PAD_DRAM_SDCKE1,
        #[doc = "SW_PAD_CTL_PAD_DRAM_RESET SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_DRAM_RESET: SW_PAD_CTL_PAD_DRAM_RESET,
        #[doc = "SW_PAD_CTL_PAD_TEST_MODE SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_TEST_MODE: SW_PAD_CTL_PAD_TEST_MODE,
        #[doc = "SW_PAD_CTL_PAD_POR_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_POR_B: SW_PAD_CTL_PAD_POR_B,
        #[doc = "SW_PAD_CTL_PAD_ONOFF SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ONOFF: SW_PAD_CTL_PAD_ONOFF,
        #[doc = "SW_PAD_CTL_PAD_BOOT_MODE0 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_BOOT_MODE0: SW_PAD_CTL_PAD_BOOT_MODE0,
        #[doc = "SW_PAD_CTL_PAD_BOOT_MODE1 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_BOOT_MODE1: SW_PAD_CTL_PAD_BOOT_MODE1,
        #[doc = "SW_PAD_CTL_PAD_JTAG_MOD SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_JTAG_MOD: SW_PAD_CTL_PAD_JTAG_MOD,
        #[doc = "SW_PAD_CTL_PAD_JTAG_TMS SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_JTAG_TMS: SW_PAD_CTL_PAD_JTAG_TMS,
        #[doc = "SW_PAD_CTL_PAD_JTAG_TDO SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_JTAG_TDO: SW_PAD_CTL_PAD_JTAG_TDO,
        #[doc = "SW_PAD_CTL_PAD_JTAG_TDI SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_JTAG_TDI: SW_PAD_CTL_PAD_JTAG_TDI,
        #[doc = "SW_PAD_CTL_PAD_JTAG_TCK SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_JTAG_TCK: SW_PAD_CTL_PAD_JTAG_TCK,
        #[doc = "SW_PAD_CTL_PAD_JTAG_TRST_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_JTAG_TRST_B: SW_PAD_CTL_PAD_JTAG_TRST_B,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO00 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO00: SW_PAD_CTL_PAD_GPIO1_IO00,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO01 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO01: SW_PAD_CTL_PAD_GPIO1_IO01,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO02 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO02: SW_PAD_CTL_PAD_GPIO1_IO02,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO03 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO03: SW_PAD_CTL_PAD_GPIO1_IO03,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO04 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO04: SW_PAD_CTL_PAD_GPIO1_IO04,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO05 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO05: SW_PAD_CTL_PAD_GPIO1_IO05,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO06 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO06: SW_PAD_CTL_PAD_GPIO1_IO06,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO07 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO07: SW_PAD_CTL_PAD_GPIO1_IO07,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO08 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO08: SW_PAD_CTL_PAD_GPIO1_IO08,
        #[doc = "SW_PAD_CTL_PAD_GPIO1_IO09 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_GPIO1_IO09: SW_PAD_CTL_PAD_GPIO1_IO09,
        #[doc = "SW_PAD_CTL_PAD_UART1_CTS_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_UART1_CTS_B: SW_PAD_CTL_PAD_UART1_CTS_B,
        #[doc = "SW_PAD_CTL_PAD_UART1_RTS_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_UART1_RTS_B: SW_PAD_CTL_PAD_UART1_RTS_B,
        #[doc = "SW_PAD_CTL_PAD_UART2_CTS_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_UART2_CTS_B: SW_PAD_CTL_PAD_UART2_CTS_B,
        #[doc = "SW_PAD_CTL_PAD_UART2_RTS_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_UART2_RTS_B: SW_PAD_CTL_PAD_UART2_RTS_B,
        #[doc = "SW_PAD_CTL_PAD_UART3_CTS_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_UART3_CTS_B: SW_PAD_CTL_PAD_UART3_CTS_B,
        #[doc = "SW_PAD_CTL_PAD_UART3_RTS_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_UART3_RTS_B: SW_PAD_CTL_PAD_UART3_RTS_B,
        #[doc = "SW_PAD_CTL_PAD_ENET1_RX_EN SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ENET1_RX_EN: SW_PAD_CTL_PAD_ENET1_RX_EN,
        #[doc = "SW_PAD_CTL_PAD_ENET1_TX_EN SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ENET1_TX_EN: SW_PAD_CTL_PAD_ENET1_TX_EN,
        #[doc = "SW_PAD_CTL_PAD_ENET1_TX_CLK SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ENET1_TX_CLK: SW_PAD_CTL_PAD_ENET1_TX_CLK,
        #[doc = "SW_PAD_CTL_PAD_ENET1_RX_ER SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ENET1_RX_ER: SW_PAD_CTL_PAD_ENET1_RX_ER,
        #[doc = "SW_PAD_CTL_PAD_ENET2_RX_EN SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ENET2_RX_EN: SW_PAD_CTL_PAD_ENET2_RX_EN,
        #[doc = "SW_PAD_CTL_PAD_ENET2_TX_EN SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ENET2_TX_EN: SW_PAD_CTL_PAD_ENET2_TX_EN,
        #[doc = "SW_PAD_CTL_PAD_ENET2_TX_CLK SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ENET2_TX_CLK: SW_PAD_CTL_PAD_ENET2_TX_CLK,
        #[doc = "SW_PAD_CTL_PAD_ENET2_RX_ER SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_ENET2_RX_ER: SW_PAD_CTL_PAD_ENET2_RX_ER,
        #[doc = "SW_PAD_CTL_PAD_LCD_CLK SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_CLK: SW_PAD_CTL_PAD_LCD_CLK,
        #[doc = "SW_PAD_CTL_PAD_LCD_ENABLE SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_ENABLE: SW_PAD_CTL_PAD_LCD_ENABLE,
        #[doc = "SW_PAD_CTL_PAD_LCD_HSYNC SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_HSYNC: SW_PAD_CTL_PAD_LCD_HSYNC,
        #[doc = "SW_PAD_CTL_PAD_LCD_VSYNC SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_VSYNC: SW_PAD_CTL_PAD_LCD_VSYNC,
        #[doc = "SW_PAD_CTL_PAD_LCD_RESET SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_RESET: SW_PAD_CTL_PAD_LCD_RESET,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA00 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA00: SW_PAD_CTL_PAD_LCD_DATA00,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA01 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA01: SW_PAD_CTL_PAD_LCD_DATA01,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA02 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA02: SW_PAD_CTL_PAD_LCD_DATA02,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA03 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA03: SW_PAD_CTL_PAD_LCD_DATA03,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA04 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA04: SW_PAD_CTL_PAD_LCD_DATA04,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA05 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA05: SW_PAD_CTL_PAD_LCD_DATA05,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA06 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA06: SW_PAD_CTL_PAD_LCD_DATA06,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA07 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA07: SW_PAD_CTL_PAD_LCD_DATA07,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA08 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA08: SW_PAD_CTL_PAD_LCD_DATA08,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA09 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA09: SW_PAD_CTL_PAD_LCD_DATA09,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA10 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA10: SW_PAD_CTL_PAD_LCD_DATA10,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA11 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA11: SW_PAD_CTL_PAD_LCD_DATA11,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA12 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA12: SW_PAD_CTL_PAD_LCD_DATA12,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA13 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA13: SW_PAD_CTL_PAD_LCD_DATA13,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA14 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA14: SW_PAD_CTL_PAD_LCD_DATA14,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA15 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA15: SW_PAD_CTL_PAD_LCD_DATA15,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA16 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA16: SW_PAD_CTL_PAD_LCD_DATA16,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA17 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA17: SW_PAD_CTL_PAD_LCD_DATA17,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA18 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA18: SW_PAD_CTL_PAD_LCD_DATA18,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA19 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA19: SW_PAD_CTL_PAD_LCD_DATA19,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA20 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA20: SW_PAD_CTL_PAD_LCD_DATA20,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA21 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA21: SW_PAD_CTL_PAD_LCD_DATA21,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA22 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA22: SW_PAD_CTL_PAD_LCD_DATA22,
        #[doc = "SW_PAD_CTL_PAD_LCD_DATA23 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_LCD_DATA23: SW_PAD_CTL_PAD_LCD_DATA23,
        #[doc = "SW_PAD_CTL_PAD_NAND_RE_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_RE_B: SW_PAD_CTL_PAD_NAND_RE_B,
        #[doc = "SW_PAD_CTL_PAD_NAND_WE_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_WE_B: SW_PAD_CTL_PAD_NAND_WE_B,
        #[doc = "SW_PAD_CTL_PAD_NAND_DATA00 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DATA00: SW_PAD_CTL_PAD_NAND_DATA00,
        #[doc = "SW_PAD_CTL_PAD_NAND_DATA01 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DATA01: SW_PAD_CTL_PAD_NAND_DATA01,
        #[doc = "SW_PAD_CTL_PAD_NAND_DATA02 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DATA02: SW_PAD_CTL_PAD_NAND_DATA02,
        #[doc = "SW_PAD_CTL_PAD_NAND_DATA03 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DATA03: SW_PAD_CTL_PAD_NAND_DATA03,
        #[doc = "SW_PAD_CTL_PAD_NAND_DATA04 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DATA04: SW_PAD_CTL_PAD_NAND_DATA04,
        #[doc = "SW_PAD_CTL_PAD_NAND_DATA05 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DATA05: SW_PAD_CTL_PAD_NAND_DATA05,
        #[doc = "SW_PAD_CTL_PAD_NAND_DATA06 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DATA06: SW_PAD_CTL_PAD_NAND_DATA06,
        #[doc = "SW_PAD_CTL_PAD_NAND_DATA07 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DATA07: SW_PAD_CTL_PAD_NAND_DATA07,
        #[doc = "SW_PAD_CTL_PAD_NAND_ALE SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_ALE: SW_PAD_CTL_PAD_NAND_ALE,
        #[doc = "SW_PAD_CTL_PAD_NAND_WP_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_WP_B: SW_PAD_CTL_PAD_NAND_WP_B,
        #[doc = "SW_PAD_CTL_PAD_NAND_CE0_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_CE0_B: SW_PAD_CTL_PAD_NAND_CE0_B,
        #[doc = "SW_PAD_CTL_PAD_NAND_CE1_B SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_CE1_B: SW_PAD_CTL_PAD_NAND_CE1_B,
        #[doc = "SW_PAD_CTL_PAD_NAND_CLE SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_CLE: SW_PAD_CTL_PAD_NAND_CLE,
        #[doc = "SW_PAD_CTL_PAD_NAND_DQS SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_NAND_DQS: SW_PAD_CTL_PAD_NAND_DQS,
        #[doc = "SW_PAD_CTL_PAD_SD1_CMD SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_SD1_CMD: SW_PAD_CTL_PAD_SD1_CMD,
        #[doc = "SW_PAD_CTL_PAD_SD1_CLK SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_SD1_CLK: SW_PAD_CTL_PAD_SD1_CLK,
        #[doc = "SW_PAD_CTL_PAD_SD1_DATA0 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_SD1_DATA0: SW_PAD_CTL_PAD_SD1_DATA0,
        #[doc = "SW_PAD_CTL_PAD_SD1_DATA1 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_SD1_DATA1: SW_PAD_CTL_PAD_SD1_DATA1,
        #[doc = "SW_PAD_CTL_PAD_SD1_DATA2 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_SD1_DATA2: SW_PAD_CTL_PAD_SD1_DATA2,
        #[doc = "SW_PAD_CTL_PAD_SD1_DATA3 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_SD1_DATA3: SW_PAD_CTL_PAD_SD1_DATA3,
        #[doc = "SW_PAD_CTL_PAD_CSI_MCLK SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_MCLK: SW_PAD_CTL_PAD_CSI_MCLK,
        #[doc = "SW_PAD_CTL_PAD_CSI_PIXCLK SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_PIXCLK: SW_PAD_CTL_PAD_CSI_PIXCLK,
        #[doc = "SW_PAD_CTL_PAD_CSI_VSYNC SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_VSYNC: SW_PAD_CTL_PAD_CSI_VSYNC,
        #[doc = "SW_PAD_CTL_PAD_CSI_HSYNC SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_HSYNC: SW_PAD_CTL_PAD_CSI_HSYNC,
        #[doc = "SW_PAD_CTL_PAD_CSI_DATA00 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_DATA00: SW_PAD_CTL_PAD_CSI_DATA00,
        #[doc = "SW_PAD_CTL_PAD_CSI_DATA01 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_DATA01: SW_PAD_CTL_PAD_CSI_DATA01,
        #[doc = "SW_PAD_CTL_PAD_CSI_DATA02 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_DATA02: SW_PAD_CTL_PAD_CSI_DATA02,
        #[doc = "SW_PAD_CTL_PAD_CSI_DATA03 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_DATA03: SW_PAD_CTL_PAD_CSI_DATA03,
        #[doc = "SW_PAD_CTL_PAD_CSI_DATA04 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_DATA04: SW_PAD_CTL_PAD_CSI_DATA04,
        #[doc = "SW_PAD_CTL_PAD_CSI_DATA05 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_DATA05: SW_PAD_CTL_PAD_CSI_DATA05,
        #[doc = "SW_PAD_CTL_PAD_CSI_DATA06 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_DATA06: SW_PAD_CTL_PAD_CSI_DATA06,
        #[doc = "SW_PAD_CTL_PAD_CSI_DATA07 SW PAD Control Register"]
        pub SW_PAD_CTL_PAD_CSI_DATA07: SW_PAD_CTL_PAD_CSI_DATA07,
        #[doc = "SW_PAD_CTL_GRP_ADDDS SW GRP Register"]
        pub SW_PAD_CTL_GRP_ADDDS: SW_PAD_CTL_GRP_ADDDS,
        #[doc = "SW_PAD_CTL_GRP_DDRMODE_CTL SW GRP Register"]
        pub SW_PAD_CTL_GRP_DDRMODE_CTL: SW_PAD_CTL_GRP_DDRMODE_CTL,
        #[doc = "SW_PAD_CTL_GRP_B0DS SW GRP Register"]
        pub SW_PAD_CTL_GRP_B0DS: SW_PAD_CTL_GRP_B0DS,
        #[doc = "SW_PAD_CTL_GRP_DDRPK SW GRP Register"]
        pub SW_PAD_CTL_GRP_DDRPK: SW_PAD_CTL_GRP_DDRPK,
        #[doc = "SW_PAD_CTL_GRP_CTLDS SW GRP Register"]
        pub SW_PAD_CTL_GRP_CTLDS: SW_PAD_CTL_GRP_CTLDS,
        #[doc = "SW_PAD_CTL_GRP_B1DS SW GRP Register"]
        pub SW_PAD_CTL_GRP_B1DS: SW_PAD_CTL_GRP_B1DS,
        #[doc = "SW_PAD_CTL_GRP_DDRHYS SW GRP Register"]
        pub SW_PAD_CTL_GRP_DDRHYS: SW_PAD_CTL_GRP_DDRHYS,
        #[doc = "SW_PAD_CTL_GRP_DDRPKE SW GRP Register"]
        pub SW_PAD_CTL_GRP_DDRPKE: SW_PAD_CTL_GRP_DDRPKE,
        #[doc = "SW_PAD_CTL_GRP_DDRMODE SW GRP Register"]
        pub SW_PAD_CTL_GRP_DDRMODE: SW_PAD_CTL_GRP_DDRMODE,
        #[doc = "SW_PAD_CTL_GRP_DDR_TYPE SW GRP Register"]
        pub SW_PAD_CTL_GRP_DDR_TYPE: SW_PAD_CTL_GRP_DDR_TYPE,
        #[doc = "USB_OTG1_ID_SELECT_INPUT DAISY Register"]
        pub USB_OTG1_ID_SELECT_INPUT: USB_OTG1_ID_SELECT_INPUT,
        #[doc = "USB_OTG2_ID_SELECT_INPUT DAISY Register"]
        pub USB_OTG2_ID_SELECT_INPUT: USB_OTG2_ID_SELECT_INPUT,
        #[doc = "CCM_PMIC_READY_SELECT_INPUT DAISY Register"]
        pub CCM_PMIC_READY_SELECT_INPUT: CCM_PMIC_READY_SELECT_INPUT,
        #[doc = "CSI_DATA02_SELECT_INPUT DAISY Register"]
        pub CSI_DATA02_SELECT_INPUT: CSI_DATA02_SELECT_INPUT,
        #[doc = "CSI_DATA03_SELECT_INPUT DAISY Register"]
        pub CSI_DATA03_SELECT_INPUT: CSI_DATA03_SELECT_INPUT,
        #[doc = "CSI_DATA05_SELECT_INPUT DAISY Register"]
        pub CSI_DATA05_SELECT_INPUT: CSI_DATA05_SELECT_INPUT,
        #[doc = "CSI_DATA00_SELECT_INPUT DAISY Register"]
        pub CSI_DATA00_SELECT_INPUT: CSI_DATA00_SELECT_INPUT,
        #[doc = "CSI_DATA01_SELECT_INPUT DAISY Register"]
        pub CSI_DATA01_SELECT_INPUT: CSI_DATA01_SELECT_INPUT,
        #[doc = "CSI_DATA04_SELECT_INPUT DAISY Register"]
        pub CSI_DATA04_SELECT_INPUT: CSI_DATA04_SELECT_INPUT,
        #[doc = "CSI_DATA06_SELECT_INPUT DAISY Register"]
        pub CSI_DATA06_SELECT_INPUT: CSI_DATA06_SELECT_INPUT,
        #[doc = "CSI_DATA07_SELECT_INPUT DAISY Register"]
        pub CSI_DATA07_SELECT_INPUT: CSI_DATA07_SELECT_INPUT,
        #[doc = "CSI_DATA08_SELECT_INPUT DAISY Register"]
        pub CSI_DATA08_SELECT_INPUT: CSI_DATA08_SELECT_INPUT,
        #[doc = "CSI_DATA09_SELECT_INPUT DAISY Register"]
        pub CSI_DATA09_SELECT_INPUT: CSI_DATA09_SELECT_INPUT,
        #[doc = "CSI_DATA10_SELECT_INPUT DAISY Register"]
        pub CSI_DATA10_SELECT_INPUT: CSI_DATA10_SELECT_INPUT,
        #[doc = "CSI_DATA11_SELECT_INPUT DAISY Register"]
        pub CSI_DATA11_SELECT_INPUT: CSI_DATA11_SELECT_INPUT,
        #[doc = "CSI_DATA12_SELECT_INPUT DAISY Register"]
        pub CSI_DATA12_SELECT_INPUT: CSI_DATA12_SELECT_INPUT,
        #[doc = "CSI_DATA13_SELECT_INPUT DAISY Register"]
        pub CSI_DATA13_SELECT_INPUT: CSI_DATA13_SELECT_INPUT,
        #[doc = "CSI_DATA14_SELECT_INPUT DAISY Register"]
        pub CSI_DATA14_SELECT_INPUT: CSI_DATA14_SELECT_INPUT,
        #[doc = "CSI_DATA15_SELECT_INPUT DAISY Register"]
        pub CSI_DATA15_SELECT_INPUT: CSI_DATA15_SELECT_INPUT,
        #[doc = "CSI_DATA16_SELECT_INPUT DAISY Register"]
        pub CSI_DATA16_SELECT_INPUT: CSI_DATA16_SELECT_INPUT,
        #[doc = "CSI_DATA17_SELECT_INPUT DAISY Register"]
        pub CSI_DATA17_SELECT_INPUT: CSI_DATA17_SELECT_INPUT,
        #[doc = "CSI_DATA18_SELECT_INPUT DAISY Register"]
        pub CSI_DATA18_SELECT_INPUT: CSI_DATA18_SELECT_INPUT,
        #[doc = "CSI_DATA19_SELECT_INPUT DAISY Register"]
        pub CSI_DATA19_SELECT_INPUT: CSI_DATA19_SELECT_INPUT,
        #[doc = "CSI_DATA20_SELECT_INPUT DAISY Register"]
        pub CSI_DATA20_SELECT_INPUT: CSI_DATA20_SELECT_INPUT,
        #[doc = "CSI_DATA21_SELECT_INPUT DAISY Register"]
        pub CSI_DATA21_SELECT_INPUT: CSI_DATA21_SELECT_INPUT,
        #[doc = "CSI_DATA22_SELECT_INPUT DAISY Register"]
        pub CSI_DATA22_SELECT_INPUT: CSI_DATA22_SELECT_INPUT,
        #[doc = "CSI_DATA23_SELECT_INPUT DAISY Register"]
        pub CSI_DATA23_SELECT_INPUT: CSI_DATA23_SELECT_INPUT,
        #[doc = "CSI_HSYNC_SELECT_INPUT DAISY Register"]
        pub CSI_HSYNC_SELECT_INPUT: CSI_HSYNC_SELECT_INPUT,
        #[doc = "CSI_PIXCLK_SELECT_INPUT DAISY Register"]
        pub CSI_PIXCLK_SELECT_INPUT: CSI_PIXCLK_SELECT_INPUT,
        #[doc = "CSI_VSYNC_SELECT_INPUT DAISY Register"]
        pub CSI_VSYNC_SELECT_INPUT: CSI_VSYNC_SELECT_INPUT,
        #[doc = "CSI_FIELD_SELECT_INPUT DAISY Register"]
        pub CSI_FIELD_SELECT_INPUT: CSI_FIELD_SELECT_INPUT,
        #[doc = "ECSPI1_SCLK_SELECT_INPUT DAISY Register"]
        pub ECSPI1_SCLK_SELECT_INPUT: ECSPI1_SCLK_SELECT_INPUT,
        #[doc = "ECSPI1_MISO_SELECT_INPUT DAISY Register"]
        pub ECSPI1_MISO_SELECT_INPUT: ECSPI1_MISO_SELECT_INPUT,
        #[doc = "ECSPI1_MOSI_SELECT_INPUT DAISY Register"]
        pub ECSPI1_MOSI_SELECT_INPUT: ECSPI1_MOSI_SELECT_INPUT,
        #[doc = "ECSPI1_SS0_B_SELECT_INPUT DAISY Register"]
        pub ECSPI1_SS0_B_SELECT_INPUT: ECSPI1_SS0_B_SELECT_INPUT,
        #[doc = "ECSPI2_SCLK_SELECT_INPUT DAISY Register"]
        pub ECSPI2_SCLK_SELECT_INPUT: ECSPI2_SCLK_SELECT_INPUT,
        #[doc = "ECSPI2_MISO_SELECT_INPUT DAISY Register"]
        pub ECSPI2_MISO_SELECT_INPUT: ECSPI2_MISO_SELECT_INPUT,
        #[doc = "ECSPI2_MOSI_SELECT_INPUT DAISY Register"]
        pub ECSPI2_MOSI_SELECT_INPUT: ECSPI2_MOSI_SELECT_INPUT,
        #[doc = "ECSPI2_SS0_B_SELECT_INPUT DAISY Register"]
        pub ECSPI2_SS0_B_SELECT_INPUT: ECSPI2_SS0_B_SELECT_INPUT,
        #[doc = "ECSPI3_SCLK_SELECT_INPUT DAISY Register"]
        pub ECSPI3_SCLK_SELECT_INPUT: ECSPI3_SCLK_SELECT_INPUT,
        #[doc = "ECSPI3_MISO_SELECT_INPUT DAISY Register"]
        pub ECSPI3_MISO_SELECT_INPUT: ECSPI3_MISO_SELECT_INPUT,
        #[doc = "ECSPI3_MOSI_SELECT_INPUT DAISY Register"]
        pub ECSPI3_MOSI_SELECT_INPUT: ECSPI3_MOSI_SELECT_INPUT,
        #[doc = "ECSPI3_SS0_B_SELECT_INPUT DAISY Register"]
        pub ECSPI3_SS0_B_SELECT_INPUT: ECSPI3_SS0_B_SELECT_INPUT,
        #[doc = "ECSPI4_SCLK_SELECT_INPUT DAISY Register"]
        pub ECSPI4_SCLK_SELECT_INPUT: ECSPI4_SCLK_SELECT_INPUT,
        #[doc = "ECSPI4_MISO_SELECT_INPUT DAISY Register"]
        pub ECSPI4_MISO_SELECT_INPUT: ECSPI4_MISO_SELECT_INPUT,
        #[doc = "ECSPI4_MOSI_SELECT_INPUT DAISY Register"]
        pub ECSPI4_MOSI_SELECT_INPUT: ECSPI4_MOSI_SELECT_INPUT,
        #[doc = "ECSPI4_SS0_B_SELECT_INPUT DAISY Register"]
        pub ECSPI4_SS0_B_SELECT_INPUT: ECSPI4_SS0_B_SELECT_INPUT,
        #[doc = "ENET1_REF_CLK1_SELECT_INPUT DAISY Register"]
        pub ENET1_REF_CLK1_SELECT_INPUT: ENET1_REF_CLK1_SELECT_INPUT,
        #[doc = "ENET1_MAC0_MDIO_SELECT_INPUT DAISY Register"]
        pub ENET1_MAC0_MDIO_SELECT_INPUT: ENET1_MAC0_MDIO_SELECT_INPUT,
        #[doc = "ENET2_REF_CLK2_SELECT_INPUT DAISY Register"]
        pub ENET2_REF_CLK2_SELECT_INPUT: ENET2_REF_CLK2_SELECT_INPUT,
        #[doc = "ENET2_MAC0_MDIO_SELECT_INPUT DAISY Register"]
        pub ENET2_MAC0_MDIO_SELECT_INPUT: ENET2_MAC0_MDIO_SELECT_INPUT,
        #[doc = "FLEXCAN1_RX_SELECT_INPUT DAISY Register"]
        pub FLEXCAN1_RX_SELECT_INPUT: FLEXCAN1_RX_SELECT_INPUT,
        #[doc = "FLEXCAN2_RX_SELECT_INPUT DAISY Register"]
        pub FLEXCAN2_RX_SELECT_INPUT: FLEXCAN2_RX_SELECT_INPUT,
        #[doc = "GPT1_CAPTURE1_SELECT_INPUT DAISY Register"]
        pub GPT1_CAPTURE1_SELECT_INPUT: GPT1_CAPTURE1_SELECT_INPUT,
        #[doc = "GPT1_CAPTURE2_SELECT_INPUT DAISY Register"]
        pub GPT1_CAPTURE2_SELECT_INPUT: GPT1_CAPTURE2_SELECT_INPUT,
        #[doc = "GPT1_CLK_SELECT_INPUT DAISY Register"]
        pub GPT1_CLK_SELECT_INPUT: GPT1_CLK_SELECT_INPUT,
        #[doc = "GPT2_CAPTURE1_SELECT_INPUT DAISY Register"]
        pub GPT2_CAPTURE1_SELECT_INPUT: GPT2_CAPTURE1_SELECT_INPUT,
        #[doc = "GPT2_CAPTURE2_SELECT_INPUT DAISY Register"]
        pub GPT2_CAPTURE2_SELECT_INPUT: GPT2_CAPTURE2_SELECT_INPUT,
        #[doc = "GPT2_CLK_SELECT_INPUT DAISY Register"]
        pub GPT2_CLK_SELECT_INPUT: GPT2_CLK_SELECT_INPUT,
        #[doc = "I2C1_SCL_SELECT_INPUT DAISY Register"]
        pub I2C1_SCL_SELECT_INPUT: I2C1_SCL_SELECT_INPUT,
        #[doc = "I2C1_SDA_SELECT_INPUT DAISY Register"]
        pub I2C1_SDA_SELECT_INPUT: I2C1_SDA_SELECT_INPUT,
        #[doc = "I2C2_SCL_SELECT_INPUT DAISY Register"]
        pub I2C2_SCL_SELECT_INPUT: I2C2_SCL_SELECT_INPUT,
        #[doc = "I2C2_SDA_SELECT_INPUT DAISY Register"]
        pub I2C2_SDA_SELECT_INPUT: I2C2_SDA_SELECT_INPUT,
        #[doc = "I2C3_SCL_SELECT_INPUT DAISY Register"]
        pub I2C3_SCL_SELECT_INPUT: I2C3_SCL_SELECT_INPUT,
        #[doc = "I2C3_SDA_SELECT_INPUT DAISY Register"]
        pub I2C3_SDA_SELECT_INPUT: I2C3_SDA_SELECT_INPUT,
        #[doc = "I2C4_SCL_SELECT_INPUT DAISY Register"]
        pub I2C4_SCL_SELECT_INPUT: I2C4_SCL_SELECT_INPUT,
        #[doc = "I2C4_SDA_SELECT_INPUT DAISY Register"]
        pub I2C4_SDA_SELECT_INPUT: I2C4_SDA_SELECT_INPUT,
        #[doc = "KPP_COL0_SELECT_INPUT DAISY Register"]
        pub KPP_COL0_SELECT_INPUT: KPP_COL0_SELECT_INPUT,
        #[doc = "KPP_COL1_SELECT_INPUT DAISY Register"]
        pub KPP_COL1_SELECT_INPUT: KPP_COL1_SELECT_INPUT,
        #[doc = "KPP_COL2_SELECT_INPUT DAISY Register"]
        pub KPP_COL2_SELECT_INPUT: KPP_COL2_SELECT_INPUT,
        #[doc = "KPP_ROW0_SELECT_INPUT DAISY Register"]
        pub KPP_ROW0_SELECT_INPUT: KPP_ROW0_SELECT_INPUT,
        #[doc = "KPP_ROW1_SELECT_INPUT DAISY Register"]
        pub KPP_ROW1_SELECT_INPUT: KPP_ROW1_SELECT_INPUT,
        #[doc = "KPP_ROW2_SELECT_INPUT DAISY Register"]
        pub KPP_ROW2_SELECT_INPUT: KPP_ROW2_SELECT_INPUT,
        #[doc = "LCD_BUSY_SELECT_INPUT DAISY Register"]
        pub LCD_BUSY_SELECT_INPUT: LCD_BUSY_SELECT_INPUT,
        #[doc = "SAI1_MCLK_SELECT_INPUT DAISY Register"]
        pub SAI1_MCLK_SELECT_INPUT: SAI1_MCLK_SELECT_INPUT,
        #[doc = "SAI1_RX_DATA_SELECT_INPUT DAISY Register"]
        pub SAI1_RX_DATA_SELECT_INPUT: SAI1_RX_DATA_SELECT_INPUT,
        #[doc = "SAI1_TX_BCLK_SELECT_INPUT DAISY Register"]
        pub SAI1_TX_BCLK_SELECT_INPUT: SAI1_TX_BCLK_SELECT_INPUT,
        #[doc = "SAI1_TX_SYNC_SELECT_INPUT DAISY Register"]
        pub SAI1_TX_SYNC_SELECT_INPUT: SAI1_TX_SYNC_SELECT_INPUT,
        #[doc = "SAI2_MCLK_SELECT_INPUT DAISY Register"]
        pub SAI2_MCLK_SELECT_INPUT: SAI2_MCLK_SELECT_INPUT,
        #[doc = "SAI2_RX_DATA_SELECT_INPUT DAISY Register"]
        pub SAI2_RX_DATA_SELECT_INPUT: SAI2_RX_DATA_SELECT_INPUT,
        #[doc = "SAI2_TX_BCLK_SELECT_INPUT DAISY Register"]
        pub SAI2_TX_BCLK_SELECT_INPUT: SAI2_TX_BCLK_SELECT_INPUT,
        #[doc = "SAI2_TX_SYNC_SELECT_INPUT DAISY Register"]
        pub SAI2_TX_SYNC_SELECT_INPUT: SAI2_TX_SYNC_SELECT_INPUT,
        #[doc = "SAI3_MCLK_SELECT_INPUT DAISY Register"]
        pub SAI3_MCLK_SELECT_INPUT: SAI3_MCLK_SELECT_INPUT,
        #[doc = "SAI3_RX_DATA_SELECT_INPUT DAISY Register"]
        pub SAI3_RX_DATA_SELECT_INPUT: SAI3_RX_DATA_SELECT_INPUT,
        #[doc = "SAI3_TX_BCLK_SELECT_INPUT DAISY Register"]
        pub SAI3_TX_BCLK_SELECT_INPUT: SAI3_TX_BCLK_SELECT_INPUT,
        #[doc = "SAI3_TX_SYNC_SELECT_INPUT DAISY Register"]
        pub SAI3_TX_SYNC_SELECT_INPUT: SAI3_TX_SYNC_SELECT_INPUT,
        #[doc = "SDMA_EVENTS0_SELECT_INPUT DAISY Register"]
        pub SDMA_EVENTS0_SELECT_INPUT: SDMA_EVENTS0_SELECT_INPUT,
        #[doc = "SDMA_EVENTS1_SELECT_INPUT DAISY Register"]
        pub SDMA_EVENTS1_SELECT_INPUT: SDMA_EVENTS1_SELECT_INPUT,
        #[doc = "SPDIF_IN_SELECT_INPUT DAISY Register"]
        pub SPDIF_IN_SELECT_INPUT: SPDIF_IN_SELECT_INPUT,
        #[doc = "SPDIF_EXT_CLK_SELECT_INPUT DAISY Register"]
        pub SPDIF_EXT_CLK_SELECT_INPUT: SPDIF_EXT_CLK_SELECT_INPUT,
        #[doc = "UART1_RTS_B_SELECT_INPUT DAISY Register"]
        pub UART1_RTS_B_SELECT_INPUT: UART1_RTS_B_SELECT_INPUT,
        #[doc = "UART1_RX_DATA_SELECT_INPUT DAISY Register"]
        pub UART1_RX_DATA_SELECT_INPUT: UART1_RX_DATA_SELECT_INPUT,
        #[doc = "UART2_RTS_B_SELECT_INPUT DAISY Register"]
        pub UART2_RTS_B_SELECT_INPUT: UART2_RTS_B_SELECT_INPUT,
        #[doc = "UART2_RX_DATA_SELECT_INPUT DAISY Register"]
        pub UART2_RX_DATA_SELECT_INPUT: UART2_RX_DATA_SELECT_INPUT,
        #[doc = "UART3_RTS_B_SELECT_INPUT DAISY Register"]
        pub UART3_RTS_B_SELECT_INPUT: UART3_RTS_B_SELECT_INPUT,
        #[doc = "UART3_RX_DATA_SELECT_INPUT DAISY Register"]
        pub UART3_RX_DATA_SELECT_INPUT: UART3_RX_DATA_SELECT_INPUT,
        #[doc = "UART4_RTS_B_SELECT_INPUT DAISY Register"]
        pub UART4_RTS_B_SELECT_INPUT: UART4_RTS_B_SELECT_INPUT,
        #[doc = "UART4_RX_DATA_SELECT_INPUT DAISY Register"]
        pub UART4_RX_DATA_SELECT_INPUT: UART4_RX_DATA_SELECT_INPUT,
        #[doc = "UART5_RTS_B_SELECT_INPUT DAISY Register"]
        pub UART5_RTS_B_SELECT_INPUT: UART5_RTS_B_SELECT_INPUT,
        #[doc = "UART5_RX_DATA_SELECT_INPUT DAISY Register"]
        pub UART5_RX_DATA_SELECT_INPUT: UART5_RX_DATA_SELECT_INPUT,
        #[doc = "UART6_RTS_B_SELECT_INPUT DAISY Register"]
        pub UART6_RTS_B_SELECT_INPUT: UART6_RTS_B_SELECT_INPUT,
        #[doc = "UART6_RX_DATA_SELECT_INPUT DAISY Register"]
        pub UART6_RX_DATA_SELECT_INPUT: UART6_RX_DATA_SELECT_INPUT,
        #[doc = "UART7_RTS_B_SELECT_INPUT DAISY Register"]
        pub UART7_RTS_B_SELECT_INPUT: UART7_RTS_B_SELECT_INPUT,
        #[doc = "UART7_RX_DATA_SELECT_INPUT DAISY Register"]
        pub UART7_RX_DATA_SELECT_INPUT: UART7_RX_DATA_SELECT_INPUT,
        #[doc = "UART8_RTS_B_SELECT_INPUT DAISY Register"]
        pub UART8_RTS_B_SELECT_INPUT: UART8_RTS_B_SELECT_INPUT,
        #[doc = "UART8_RX_DATA_SELECT_INPUT DAISY Register"]
        pub UART8_RX_DATA_SELECT_INPUT: UART8_RX_DATA_SELECT_INPUT,
        #[doc = "USB_OTG2_OC_SELECT_INPUT DAISY Register"]
        pub USB_OTG2_OC_SELECT_INPUT: USB_OTG2_OC_SELECT_INPUT,
        #[doc = "USB_OTG_OC_SELECT_INPUT DAISY Register"]
        pub USB_OTG_OC_SELECT_INPUT: USB_OTG_OC_SELECT_INPUT,
        #[doc = "USDHC1_CD_B_SELECT_INPUT DAISY Register"]
        pub USDHC1_CD_B_SELECT_INPUT: USDHC1_CD_B_SELECT_INPUT,
        #[doc = "USDHC1_WP_SELECT_INPUT DAISY Register"]
        pub USDHC1_WP_SELECT_INPUT: USDHC1_WP_SELECT_INPUT,
        #[doc = "USDHC2_CLK_SELECT_INPUT DAISY Register"]
        pub USDHC2_CLK_SELECT_INPUT: USDHC2_CLK_SELECT_INPUT,
        #[doc = "USDHC2_CD_B_SELECT_INPUT DAISY Register"]
        pub USDHC2_CD_B_SELECT_INPUT: USDHC2_CD_B_SELECT_INPUT,
        #[doc = "USDHC2_CMD_SELECT_INPUT DAISY Register"]
        pub USDHC2_CMD_SELECT_INPUT: USDHC2_CMD_SELECT_INPUT,
        #[doc = "USDHC2_DATA0_SELECT_INPUT DAISY Register"]
        pub USDHC2_DATA0_SELECT_INPUT: USDHC2_DATA0_SELECT_INPUT,
        #[doc = "USDHC2_DATA1_SELECT_INPUT DAISY Register"]
        pub USDHC2_DATA1_SELECT_INPUT: USDHC2_DATA1_SELECT_INPUT,
        #[doc = "USDHC2_DATA2_SELECT_INPUT DAISY Register"]
        pub USDHC2_DATA2_SELECT_INPUT: USDHC2_DATA2_SELECT_INPUT,
        #[doc = "USDHC2_DATA3_SELECT_INPUT DAISY Register"]
        pub USDHC2_DATA3_SELECT_INPUT: USDHC2_DATA3_SELECT_INPUT,
        #[doc = "USDHC2_DATA4_SELECT_INPUT DAISY Register"]
        pub USDHC2_DATA4_SELECT_INPUT: USDHC2_DATA4_SELECT_INPUT,
        #[doc = "USDHC2_DATA5_SELECT_INPUT DAISY Register"]
        pub USDHC2_DATA5_SELECT_INPUT: USDHC2_DATA5_SELECT_INPUT,
        #[doc = "USDHC2_DATA6_SELECT_INPUT DAISY Register"]
        pub USDHC2_DATA6_SELECT_INPUT: USDHC2_DATA6_SELECT_INPUT,
        #[doc = "USDHC2_DATA7_SELECT_INPUT DAISY Register"]
        pub USDHC2_DATA7_SELECT_INPUT: USDHC2_DATA7_SELECT_INPUT,
        #[doc = "USDHC2_WP_SELECT_INPUT DAISY Register"]
        pub USDHC2_WP_SELECT_INPUT: USDHC2_WP_SELECT_INPUT,
    }
    unsafe impl Send for Registers {}
    #[doc = "SW_MUX_CTL_PAD_BOOT_MODE0 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_BOOT_MODE0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_BOOT_MODE0 {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_BOOT_MODE1 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_BOOT_MODE1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_BOOT_MODE1 {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_JTAG_MOD SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_JTAG_MOD {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_JTAG_MOD {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_JTAG_TMS SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_JTAG_TMS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_JTAG_TMS {
        const OFFSET: usize = 0x34;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_JTAG_TDO SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_JTAG_TDO {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_JTAG_TDO {
        const OFFSET: usize = 0x38;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_JTAG_TDI SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_JTAG_TDI {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_JTAG_TDI {
        const OFFSET: usize = 0x3c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_JTAG_TCK SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_JTAG_TCK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_JTAG_TCK {
        const OFFSET: usize = 0x40;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_JTAG_TRST_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_JTAG_TRST_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_JTAG_TRST_B {
        const OFFSET: usize = 0x44;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO00 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO00 {
        const OFFSET: usize = 0x48;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO01 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO01 {
        const OFFSET: usize = 0x4c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO02 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO02 {
        const OFFSET: usize = 0x50;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO03 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO03 {
        const OFFSET: usize = 0x54;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO04 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO04 {
        const OFFSET: usize = 0x58;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO05 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO05 {
        const OFFSET: usize = 0x5c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO06 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO06 {
        const OFFSET: usize = 0x60;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO07 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO07 {
        const OFFSET: usize = 0x64;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO08 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO08 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO08 {
        const OFFSET: usize = 0x68;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_GPIO1_IO09 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_GPIO1_IO09 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_GPIO1_IO09 {
        const OFFSET: usize = 0x6c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_UART1_CTS_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_UART1_CTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_UART1_CTS_B {
        const OFFSET: usize = 0x78;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_UART1_RTS_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_UART1_RTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_UART1_RTS_B {
        const OFFSET: usize = 0x7c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_UART2_CTS_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_UART2_CTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_UART2_CTS_B {
        const OFFSET: usize = 0x88;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_UART2_RTS_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_UART2_RTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_UART2_RTS_B {
        const OFFSET: usize = 0x8c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_UART3_CTS_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_UART3_CTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_UART3_CTS_B {
        const OFFSET: usize = 0x98;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_UART3_RTS_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_UART3_RTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_UART3_RTS_B {
        const OFFSET: usize = 0x9c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_ENET1_RX_EN SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_ENET1_RX_EN {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_ENET1_RX_EN {
        const OFFSET: usize = 0xb8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_ENET1_TX_EN SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_ENET1_TX_EN {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_ENET1_TX_EN {
        const OFFSET: usize = 0xc4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_ENET1_TX_CLK SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_ENET1_TX_CLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_ENET1_TX_CLK {
        const OFFSET: usize = 0xc8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_ENET1_RX_ER SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_ENET1_RX_ER {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_ENET1_RX_ER {
        const OFFSET: usize = 0xcc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_ENET2_RX_EN SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_ENET2_RX_EN {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_ENET2_RX_EN {
        const OFFSET: usize = 0xd8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_ENET2_TX_EN SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_ENET2_TX_EN {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_ENET2_TX_EN {
        const OFFSET: usize = 0xe4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_ENET2_TX_CLK SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_ENET2_TX_CLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_ENET2_TX_CLK {
        const OFFSET: usize = 0xe8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_ENET2_RX_ER SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_ENET2_RX_ER {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_ENET2_RX_ER {
        const OFFSET: usize = 0xec;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_CLK SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_CLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_CLK {
        const OFFSET: usize = 0xf0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_ENABLE SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_ENABLE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_ENABLE {
        const OFFSET: usize = 0xf4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_HSYNC SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_HSYNC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_HSYNC {
        const OFFSET: usize = 0xf8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_VSYNC SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_VSYNC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_VSYNC {
        const OFFSET: usize = 0xfc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_RESET SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_RESET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_RESET {
        const OFFSET: usize = 0x0100;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA00 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA00 {
        const OFFSET: usize = 0x0104;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA01 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA01 {
        const OFFSET: usize = 0x0108;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA02 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA02 {
        const OFFSET: usize = 0x010c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA03 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA03 {
        const OFFSET: usize = 0x0110;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA04 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA04 {
        const OFFSET: usize = 0x0114;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA05 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA05 {
        const OFFSET: usize = 0x0118;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA06 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA06 {
        const OFFSET: usize = 0x011c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA07 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA07 {
        const OFFSET: usize = 0x0120;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA08 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA08 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA08 {
        const OFFSET: usize = 0x0124;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA09 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA09 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA09 {
        const OFFSET: usize = 0x0128;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA10 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA10 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA10 {
        const OFFSET: usize = 0x012c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA11 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA11 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA11 {
        const OFFSET: usize = 0x0130;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA12 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA12 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA12 {
        const OFFSET: usize = 0x0134;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA13 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA13 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA13 {
        const OFFSET: usize = 0x0138;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA14 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA14 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA14 {
        const OFFSET: usize = 0x013c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA15 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA15 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA15 {
        const OFFSET: usize = 0x0140;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA16 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA16 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA16 {
        const OFFSET: usize = 0x0144;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA17 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA17 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA17 {
        const OFFSET: usize = 0x0148;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA18 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA18 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA18 {
        const OFFSET: usize = 0x014c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA19 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA19 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA19 {
        const OFFSET: usize = 0x0150;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA20 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA20 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA20 {
        const OFFSET: usize = 0x0154;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA21 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA21 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA21 {
        const OFFSET: usize = 0x0158;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA22 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA22 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA22 {
        const OFFSET: usize = 0x015c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_LCD_DATA23 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_LCD_DATA23 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_LCD_DATA23 {
        const OFFSET: usize = 0x0160;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_RE_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_RE_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_RE_B {
        const OFFSET: usize = 0x0164;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_WE_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_WE_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_WE_B {
        const OFFSET: usize = 0x0168;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DATA00 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DATA00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DATA00 {
        const OFFSET: usize = 0x016c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DATA01 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DATA01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DATA01 {
        const OFFSET: usize = 0x0170;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DATA02 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DATA02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DATA02 {
        const OFFSET: usize = 0x0174;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DATA03 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DATA03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DATA03 {
        const OFFSET: usize = 0x0178;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DATA04 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DATA04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DATA04 {
        const OFFSET: usize = 0x017c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DATA05 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DATA05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DATA05 {
        const OFFSET: usize = 0x0180;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DATA06 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DATA06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DATA06 {
        const OFFSET: usize = 0x0184;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DATA07 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DATA07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DATA07 {
        const OFFSET: usize = 0x0188;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_ALE SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_ALE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_ALE {
        const OFFSET: usize = 0x018c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_WP_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_WP_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_WP_B {
        const OFFSET: usize = 0x0190;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_CE0_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_CE0_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_CE0_B {
        const OFFSET: usize = 0x0198;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_CE1_B SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_CE1_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_CE1_B {
        const OFFSET: usize = 0x019c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_CLE SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_CLE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_CLE {
        const OFFSET: usize = 0x01a0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_NAND_DQS SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_NAND_DQS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_NAND_DQS {
        const OFFSET: usize = 0x01a4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_SD1_CMD SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_SD1_CMD {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_SD1_CMD {
        const OFFSET: usize = 0x01a8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_SD1_CLK SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_SD1_CLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_SD1_CLK {
        const OFFSET: usize = 0x01ac;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_SD1_DATA0 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_SD1_DATA0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_SD1_DATA0 {
        const OFFSET: usize = 0x01b0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_SD1_DATA1 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_SD1_DATA1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_SD1_DATA1 {
        const OFFSET: usize = 0x01b4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_SD1_DATA2 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_SD1_DATA2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_SD1_DATA2 {
        const OFFSET: usize = 0x01b8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_SD1_DATA3 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_SD1_DATA3 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_SD1_DATA3 {
        const OFFSET: usize = 0x01bc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_MCLK SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_MCLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_MCLK {
        const OFFSET: usize = 0x01c0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_PIXCLK SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_PIXCLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_PIXCLK {
        const OFFSET: usize = 0x01c4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_VSYNC SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_VSYNC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_VSYNC {
        const OFFSET: usize = 0x01c8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_HSYNC SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_HSYNC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_HSYNC {
        const OFFSET: usize = 0x01cc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_DATA00 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_DATA00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_DATA00 {
        const OFFSET: usize = 0x01d0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_DATA01 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_DATA01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_DATA01 {
        const OFFSET: usize = 0x01d4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_DATA02 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_DATA02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_DATA02 {
        const OFFSET: usize = 0x01d8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_DATA03 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_DATA03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_DATA03 {
        const OFFSET: usize = 0x01dc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_DATA04 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_DATA04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_DATA04 {
        const OFFSET: usize = 0x01e0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_DATA05 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_DATA05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_DATA05 {
        const OFFSET: usize = 0x01e4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_DATA06 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_DATA06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_DATA06 {
        const OFFSET: usize = 0x01e8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_MUX_CTL_PAD_CSI_DATA07 SW MUX Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_MUX_CTL_PAD_CSI_DATA07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_MUX_CTL_PAD_CSI_DATA07 {
        const OFFSET: usize = 0x01ec;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0005;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR00 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR00 {
        const OFFSET: usize = 0x01f0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR01 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR01 {
        const OFFSET: usize = 0x01f4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR02 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR02 {
        const OFFSET: usize = 0x01f8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR03 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR03 {
        const OFFSET: usize = 0x01fc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR04 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR04 {
        const OFFSET: usize = 0x0200;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR05 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR05 {
        const OFFSET: usize = 0x0204;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR06 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR06 {
        const OFFSET: usize = 0x0208;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR07 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR07 {
        const OFFSET: usize = 0x020c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR08 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR08 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR08 {
        const OFFSET: usize = 0x0210;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR09 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR09 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR09 {
        const OFFSET: usize = 0x0214;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR10 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR10 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR10 {
        const OFFSET: usize = 0x0218;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR11 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR11 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR11 {
        const OFFSET: usize = 0x021c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR12 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR12 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR12 {
        const OFFSET: usize = 0x0220;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR13 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR13 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR13 {
        const OFFSET: usize = 0x0224;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR14 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR14 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR14 {
        const OFFSET: usize = 0x0228;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ADDR15 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ADDR15 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ADDR15 {
        const OFFSET: usize = 0x022c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_DQM0 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_DQM0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_DQM0 {
        const OFFSET: usize = 0x0230;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_DQM1 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_DQM1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_DQM1 {
        const OFFSET: usize = 0x0234;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_RAS_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_RAS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_RAS_B {
        const OFFSET: usize = 0x0238;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_CAS_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_CAS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_CAS_B {
        const OFFSET: usize = 0x023c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_CS0_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_CS0_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_CS0_B {
        const OFFSET: usize = 0x0240;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_CS1_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_CS1_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_CS1_B {
        const OFFSET: usize = 0x0244;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_SDWE_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_SDWE_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_SDWE_B {
        const OFFSET: usize = 0x0248;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ODT0 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ODT0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ODT0 {
        const OFFSET: usize = 0x024c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_3030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_ODT1 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_ODT1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_ODT1 {
        const OFFSET: usize = 0x0250;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_3030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_SDBA0 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_SDBA0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_SDBA0 {
        const OFFSET: usize = 0x0254;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_SDBA1 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_SDBA1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_SDBA1 {
        const OFFSET: usize = 0x0258;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_SDBA2 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_SDBA2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_SDBA2 {
        const OFFSET: usize = 0x025c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_b000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_SDCKE0 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_SDCKE0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_SDCKE0 {
        const OFFSET: usize = 0x0260;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_3000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_SDCKE1 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_SDCKE1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_SDCKE1 {
        const OFFSET: usize = 0x0264;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_3000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_DRAM_RESET SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_DRAM_RESET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_DRAM_RESET {
        const OFFSET: usize = 0x0274;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0008_3030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_TEST_MODE SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_TEST_MODE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_TEST_MODE {
        const OFFSET: usize = 0x0278;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_30a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_POR_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_POR_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_POR_B {
        const OFFSET: usize = 0x027c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_b0a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ONOFF SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ONOFF {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ONOFF {
        const OFFSET: usize = 0x0280;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_b0a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_BOOT_MODE0 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_BOOT_MODE0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_BOOT_MODE0 {
        const OFFSET: usize = 0x028c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_30a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_BOOT_MODE1 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_BOOT_MODE1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_BOOT_MODE1 {
        const OFFSET: usize = 0x0290;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_30a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_JTAG_MOD SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_JTAG_MOD {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_JTAG_MOD {
        const OFFSET: usize = 0x02bc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_b0a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_JTAG_TMS SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_JTAG_TMS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_JTAG_TMS {
        const OFFSET: usize = 0x02c0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_70a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_JTAG_TDO SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_JTAG_TDO {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_JTAG_TDO {
        const OFFSET: usize = 0x02c4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_b0b1;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_JTAG_TDI SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_JTAG_TDI {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_JTAG_TDI {
        const OFFSET: usize = 0x02c8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_70a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_JTAG_TCK SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_JTAG_TCK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_JTAG_TCK {
        const OFFSET: usize = 0x02cc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_70a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_JTAG_TRST_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_JTAG_TRST_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_JTAG_TRST_B {
        const OFFSET: usize = 0x02d0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_70a0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO00 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO00 {
        const OFFSET: usize = 0x02d4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO01 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO01 {
        const OFFSET: usize = 0x02d8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO02 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO02 {
        const OFFSET: usize = 0x02dc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO03 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO03 {
        const OFFSET: usize = 0x02e0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO04 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO04 {
        const OFFSET: usize = 0x02e4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO05 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO05 {
        const OFFSET: usize = 0x02e8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO06 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO06 {
        const OFFSET: usize = 0x02ec;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO07 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO07 {
        const OFFSET: usize = 0x02f0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO08 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO08 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO08 {
        const OFFSET: usize = 0x02f4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_GPIO1_IO09 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_GPIO1_IO09 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_GPIO1_IO09 {
        const OFFSET: usize = 0x02f8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_UART1_CTS_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_UART1_CTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_UART1_CTS_B {
        const OFFSET: usize = 0x0304;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_UART1_RTS_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_UART1_RTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_UART1_RTS_B {
        const OFFSET: usize = 0x0308;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_UART2_CTS_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_UART2_CTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_UART2_CTS_B {
        const OFFSET: usize = 0x0314;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_UART2_RTS_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_UART2_RTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_UART2_RTS_B {
        const OFFSET: usize = 0x0318;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_UART3_CTS_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_UART3_CTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_UART3_CTS_B {
        const OFFSET: usize = 0x0324;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_UART3_RTS_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_UART3_RTS_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_UART3_RTS_B {
        const OFFSET: usize = 0x0328;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ENET1_RX_EN SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ENET1_RX_EN {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ENET1_RX_EN {
        const OFFSET: usize = 0x0344;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ENET1_TX_EN SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ENET1_TX_EN {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ENET1_TX_EN {
        const OFFSET: usize = 0x0350;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ENET1_TX_CLK SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ENET1_TX_CLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ENET1_TX_CLK {
        const OFFSET: usize = 0x0354;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ENET1_RX_ER SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ENET1_RX_ER {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ENET1_RX_ER {
        const OFFSET: usize = 0x0358;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ENET2_RX_EN SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ENET2_RX_EN {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ENET2_RX_EN {
        const OFFSET: usize = 0x0364;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ENET2_TX_EN SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ENET2_TX_EN {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ENET2_TX_EN {
        const OFFSET: usize = 0x0370;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ENET2_TX_CLK SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ENET2_TX_CLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ENET2_TX_CLK {
        const OFFSET: usize = 0x0374;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_ENET2_RX_ER SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_ENET2_RX_ER {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_ENET2_RX_ER {
        const OFFSET: usize = 0x0378;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_CLK SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_CLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_CLK {
        const OFFSET: usize = 0x037c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_ENABLE SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_ENABLE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_ENABLE {
        const OFFSET: usize = 0x0380;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_HSYNC SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_HSYNC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_HSYNC {
        const OFFSET: usize = 0x0384;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_VSYNC SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_VSYNC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_VSYNC {
        const OFFSET: usize = 0x0388;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_RESET SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_RESET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_RESET {
        const OFFSET: usize = 0x038c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA00 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA00 {
        const OFFSET: usize = 0x0390;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA01 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA01 {
        const OFFSET: usize = 0x0394;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA02 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA02 {
        const OFFSET: usize = 0x0398;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA03 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA03 {
        const OFFSET: usize = 0x039c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA04 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA04 {
        const OFFSET: usize = 0x03a0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA05 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA05 {
        const OFFSET: usize = 0x03a4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA06 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA06 {
        const OFFSET: usize = 0x03a8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA07 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA07 {
        const OFFSET: usize = 0x03ac;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA08 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA08 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA08 {
        const OFFSET: usize = 0x03b0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA09 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA09 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA09 {
        const OFFSET: usize = 0x03b4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA10 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA10 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA10 {
        const OFFSET: usize = 0x03b8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA11 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA11 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA11 {
        const OFFSET: usize = 0x03bc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA12 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA12 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA12 {
        const OFFSET: usize = 0x03c0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA13 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA13 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA13 {
        const OFFSET: usize = 0x03c4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA14 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA14 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA14 {
        const OFFSET: usize = 0x03c8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA15 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA15 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA15 {
        const OFFSET: usize = 0x03cc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA16 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA16 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA16 {
        const OFFSET: usize = 0x03d0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA17 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA17 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA17 {
        const OFFSET: usize = 0x03d4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA18 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA18 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA18 {
        const OFFSET: usize = 0x03d8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA19 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA19 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA19 {
        const OFFSET: usize = 0x03dc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA20 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA20 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA20 {
        const OFFSET: usize = 0x03e0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA21 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA21 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA21 {
        const OFFSET: usize = 0x03e4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA22 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA22 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA22 {
        const OFFSET: usize = 0x03e8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_LCD_DATA23 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_LCD_DATA23 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_LCD_DATA23 {
        const OFFSET: usize = 0x03ec;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_RE_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_RE_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_RE_B {
        const OFFSET: usize = 0x03f0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_WE_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_WE_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_WE_B {
        const OFFSET: usize = 0x03f4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DATA00 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DATA00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DATA00 {
        const OFFSET: usize = 0x03f8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DATA01 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DATA01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DATA01 {
        const OFFSET: usize = 0x03fc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DATA02 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DATA02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DATA02 {
        const OFFSET: usize = 0x0400;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DATA03 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DATA03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DATA03 {
        const OFFSET: usize = 0x0404;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DATA04 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DATA04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DATA04 {
        const OFFSET: usize = 0x0408;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DATA05 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DATA05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DATA05 {
        const OFFSET: usize = 0x040c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DATA06 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DATA06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DATA06 {
        const OFFSET: usize = 0x0410;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DATA07 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DATA07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DATA07 {
        const OFFSET: usize = 0x0414;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_ALE SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_ALE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_ALE {
        const OFFSET: usize = 0x0418;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_WP_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_WP_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_WP_B {
        const OFFSET: usize = 0x041c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_CE0_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_CE0_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_CE0_B {
        const OFFSET: usize = 0x0424;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_CE1_B SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_CE1_B {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_CE1_B {
        const OFFSET: usize = 0x0428;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_CLE SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_CLE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_CLE {
        const OFFSET: usize = 0x042c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_NAND_DQS SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_NAND_DQS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_NAND_DQS {
        const OFFSET: usize = 0x0430;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_SD1_CMD SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_SD1_CMD {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_SD1_CMD {
        const OFFSET: usize = 0x0434;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_SD1_CLK SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_SD1_CLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_SD1_CLK {
        const OFFSET: usize = 0x0438;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_SD1_DATA0 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_SD1_DATA0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_SD1_DATA0 {
        const OFFSET: usize = 0x043c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_SD1_DATA1 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_SD1_DATA1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_SD1_DATA1 {
        const OFFSET: usize = 0x0440;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_SD1_DATA2 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_SD1_DATA2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_SD1_DATA2 {
        const OFFSET: usize = 0x0444;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_SD1_DATA3 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_SD1_DATA3 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_SD1_DATA3 {
        const OFFSET: usize = 0x0448;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_MCLK SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_MCLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_MCLK {
        const OFFSET: usize = 0x044c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_PIXCLK SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_PIXCLK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_PIXCLK {
        const OFFSET: usize = 0x0450;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_VSYNC SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_VSYNC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_VSYNC {
        const OFFSET: usize = 0x0454;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_HSYNC SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_HSYNC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_HSYNC {
        const OFFSET: usize = 0x0458;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_DATA00 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_DATA00 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_DATA00 {
        const OFFSET: usize = 0x045c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_DATA01 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_DATA01 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_DATA01 {
        const OFFSET: usize = 0x0460;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_DATA02 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_DATA02 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_DATA02 {
        const OFFSET: usize = 0x0464;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_DATA03 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_DATA03 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_DATA03 {
        const OFFSET: usize = 0x0468;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_DATA04 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_DATA04 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_DATA04 {
        const OFFSET: usize = 0x046c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_DATA05 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_DATA05 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_DATA05 {
        const OFFSET: usize = 0x0470;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_DATA06 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_DATA06 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_DATA06 {
        const OFFSET: usize = 0x0474;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_PAD_CSI_DATA07 SW PAD Control Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_PAD_CSI_DATA07 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_PAD_CSI_DATA07 {
        const OFFSET: usize = 0x0478;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_10b0;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_ADDDS SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_ADDDS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_ADDDS {
        const OFFSET: usize = 0x047c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_DDRMODE_CTL SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_DDRMODE_CTL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_DDRMODE_CTL {
        const OFFSET: usize = 0x0480;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_B0DS SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_B0DS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_B0DS {
        const OFFSET: usize = 0x0484;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_DDRPK SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_DDRPK {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_DDRPK {
        const OFFSET: usize = 0x0488;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_2000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_CTLDS SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_CTLDS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_CTLDS {
        const OFFSET: usize = 0x048c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_B1DS SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_B1DS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_B1DS {
        const OFFSET: usize = 0x0490;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_DDRHYS SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_DDRHYS {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_DDRHYS {
        const OFFSET: usize = 0x0494;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_DDRPKE SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_DDRPKE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_DDRPKE {
        const OFFSET: usize = 0x0498;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_1000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_DDRMODE SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_DDRMODE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_DDRMODE {
        const OFFSET: usize = 0x049c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SW_PAD_CTL_GRP_DDR_TYPE SW GRP Register"]
    #[allow(non_camel_case_types)]
    pub struct SW_PAD_CTL_GRP_DDR_TYPE {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SW_PAD_CTL_GRP_DDR_TYPE {
        const OFFSET: usize = 0x04a0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0008_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB_OTG1_ID_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USB_OTG1_ID_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB_OTG1_ID_SELECT_INPUT {
        const OFFSET: usize = 0x04a4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB_OTG2_ID_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USB_OTG2_ID_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB_OTG2_ID_SELECT_INPUT {
        const OFFSET: usize = 0x04a8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CCM_PMIC_READY_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CCM_PMIC_READY_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CCM_PMIC_READY_SELECT_INPUT {
        const OFFSET: usize = 0x04ac;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA02_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA02_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA02_SELECT_INPUT {
        const OFFSET: usize = 0x04b0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA03_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA03_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA03_SELECT_INPUT {
        const OFFSET: usize = 0x04b4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA05_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA05_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA05_SELECT_INPUT {
        const OFFSET: usize = 0x04b8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA00_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA00_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA00_SELECT_INPUT {
        const OFFSET: usize = 0x04bc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA01_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA01_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA01_SELECT_INPUT {
        const OFFSET: usize = 0x04c0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA04_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA04_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA04_SELECT_INPUT {
        const OFFSET: usize = 0x04c4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA06_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA06_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA06_SELECT_INPUT {
        const OFFSET: usize = 0x04c8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA07_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA07_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA07_SELECT_INPUT {
        const OFFSET: usize = 0x04cc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA08_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA08_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA08_SELECT_INPUT {
        const OFFSET: usize = 0x04d0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA09_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA09_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA09_SELECT_INPUT {
        const OFFSET: usize = 0x04d4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA10_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA10_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA10_SELECT_INPUT {
        const OFFSET: usize = 0x04d8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA11_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA11_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA11_SELECT_INPUT {
        const OFFSET: usize = 0x04dc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA12_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA12_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA12_SELECT_INPUT {
        const OFFSET: usize = 0x04e0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA13_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA13_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA13_SELECT_INPUT {
        const OFFSET: usize = 0x04e4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA14_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA14_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA14_SELECT_INPUT {
        const OFFSET: usize = 0x04e8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA15_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA15_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA15_SELECT_INPUT {
        const OFFSET: usize = 0x04ec;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA16_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA16_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA16_SELECT_INPUT {
        const OFFSET: usize = 0x04f0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA17_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA17_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA17_SELECT_INPUT {
        const OFFSET: usize = 0x04f4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA18_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA18_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA18_SELECT_INPUT {
        const OFFSET: usize = 0x04f8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA19_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA19_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA19_SELECT_INPUT {
        const OFFSET: usize = 0x04fc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA20_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA20_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA20_SELECT_INPUT {
        const OFFSET: usize = 0x0500;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA21_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA21_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA21_SELECT_INPUT {
        const OFFSET: usize = 0x0504;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA22_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA22_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA22_SELECT_INPUT {
        const OFFSET: usize = 0x0508;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_DATA23_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_DATA23_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_DATA23_SELECT_INPUT {
        const OFFSET: usize = 0x050c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_HSYNC_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_HSYNC_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_HSYNC_SELECT_INPUT {
        const OFFSET: usize = 0x0510;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_PIXCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_PIXCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_PIXCLK_SELECT_INPUT {
        const OFFSET: usize = 0x0514;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_VSYNC_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_VSYNC_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_VSYNC_SELECT_INPUT {
        const OFFSET: usize = 0x0518;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "CSI_FIELD_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct CSI_FIELD_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CSI_FIELD_SELECT_INPUT {
        const OFFSET: usize = 0x051c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI1_SCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI1_SCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI1_SCLK_SELECT_INPUT {
        const OFFSET: usize = 0x0520;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI1_MISO_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI1_MISO_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI1_MISO_SELECT_INPUT {
        const OFFSET: usize = 0x0524;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI1_MOSI_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI1_MOSI_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI1_MOSI_SELECT_INPUT {
        const OFFSET: usize = 0x0528;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI1_SS0_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI1_SS0_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI1_SS0_B_SELECT_INPUT {
        const OFFSET: usize = 0x052c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI2_SCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI2_SCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI2_SCLK_SELECT_INPUT {
        const OFFSET: usize = 0x0530;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI2_MISO_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI2_MISO_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI2_MISO_SELECT_INPUT {
        const OFFSET: usize = 0x0534;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI2_MOSI_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI2_MOSI_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI2_MOSI_SELECT_INPUT {
        const OFFSET: usize = 0x0538;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI2_SS0_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI2_SS0_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI2_SS0_B_SELECT_INPUT {
        const OFFSET: usize = 0x053c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI3_SCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI3_SCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI3_SCLK_SELECT_INPUT {
        const OFFSET: usize = 0x0540;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI3_MISO_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI3_MISO_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI3_MISO_SELECT_INPUT {
        const OFFSET: usize = 0x0544;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI3_MOSI_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI3_MOSI_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI3_MOSI_SELECT_INPUT {
        const OFFSET: usize = 0x0548;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI3_SS0_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI3_SS0_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI3_SS0_B_SELECT_INPUT {
        const OFFSET: usize = 0x054c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI4_SCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI4_SCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI4_SCLK_SELECT_INPUT {
        const OFFSET: usize = 0x0550;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI4_MISO_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI4_MISO_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI4_MISO_SELECT_INPUT {
        const OFFSET: usize = 0x0554;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI4_MOSI_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI4_MOSI_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI4_MOSI_SELECT_INPUT {
        const OFFSET: usize = 0x0558;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ECSPI4_SS0_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ECSPI4_SS0_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ECSPI4_SS0_B_SELECT_INPUT {
        const OFFSET: usize = 0x055c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ENET1_REF_CLK1_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ENET1_REF_CLK1_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ENET1_REF_CLK1_SELECT_INPUT {
        const OFFSET: usize = 0x0560;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ENET1_MAC0_MDIO_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ENET1_MAC0_MDIO_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ENET1_MAC0_MDIO_SELECT_INPUT {
        const OFFSET: usize = 0x0564;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ENET2_REF_CLK2_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ENET2_REF_CLK2_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ENET2_REF_CLK2_SELECT_INPUT {
        const OFFSET: usize = 0x0568;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "ENET2_MAC0_MDIO_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct ENET2_MAC0_MDIO_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ENET2_MAC0_MDIO_SELECT_INPUT {
        const OFFSET: usize = 0x056c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "FLEXCAN1_RX_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct FLEXCAN1_RX_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl FLEXCAN1_RX_SELECT_INPUT {
        const OFFSET: usize = 0x0570;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "FLEXCAN2_RX_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct FLEXCAN2_RX_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl FLEXCAN2_RX_SELECT_INPUT {
        const OFFSET: usize = 0x0574;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "GPT1_CAPTURE1_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct GPT1_CAPTURE1_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl GPT1_CAPTURE1_SELECT_INPUT {
        const OFFSET: usize = 0x0578;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "GPT1_CAPTURE2_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct GPT1_CAPTURE2_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl GPT1_CAPTURE2_SELECT_INPUT {
        const OFFSET: usize = 0x057c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "GPT1_CLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct GPT1_CLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl GPT1_CLK_SELECT_INPUT {
        const OFFSET: usize = 0x0580;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "GPT2_CAPTURE1_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct GPT2_CAPTURE1_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl GPT2_CAPTURE1_SELECT_INPUT {
        const OFFSET: usize = 0x0584;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "GPT2_CAPTURE2_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct GPT2_CAPTURE2_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl GPT2_CAPTURE2_SELECT_INPUT {
        const OFFSET: usize = 0x0588;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "GPT2_CLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct GPT2_CLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl GPT2_CLK_SELECT_INPUT {
        const OFFSET: usize = 0x058c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "I2C1_SCL_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct I2C1_SCL_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl I2C1_SCL_SELECT_INPUT {
        const OFFSET: usize = 0x0590;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "I2C1_SDA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct I2C1_SDA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl I2C1_SDA_SELECT_INPUT {
        const OFFSET: usize = 0x0594;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "I2C2_SCL_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct I2C2_SCL_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl I2C2_SCL_SELECT_INPUT {
        const OFFSET: usize = 0x0598;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "I2C2_SDA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct I2C2_SDA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl I2C2_SDA_SELECT_INPUT {
        const OFFSET: usize = 0x059c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "I2C3_SCL_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct I2C3_SCL_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl I2C3_SCL_SELECT_INPUT {
        const OFFSET: usize = 0x05a0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "I2C3_SDA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct I2C3_SDA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl I2C3_SDA_SELECT_INPUT {
        const OFFSET: usize = 0x05a4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "I2C4_SCL_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct I2C4_SCL_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl I2C4_SCL_SELECT_INPUT {
        const OFFSET: usize = 0x05a8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "I2C4_SDA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct I2C4_SDA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl I2C4_SDA_SELECT_INPUT {
        const OFFSET: usize = 0x05ac;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "KPP_COL0_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct KPP_COL0_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl KPP_COL0_SELECT_INPUT {
        const OFFSET: usize = 0x05b0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "KPP_COL1_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct KPP_COL1_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl KPP_COL1_SELECT_INPUT {
        const OFFSET: usize = 0x05b4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "KPP_COL2_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct KPP_COL2_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl KPP_COL2_SELECT_INPUT {
        const OFFSET: usize = 0x05b8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "KPP_ROW0_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct KPP_ROW0_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl KPP_ROW0_SELECT_INPUT {
        const OFFSET: usize = 0x05bc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "KPP_ROW1_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct KPP_ROW1_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl KPP_ROW1_SELECT_INPUT {
        const OFFSET: usize = 0x05c0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "KPP_ROW2_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct KPP_ROW2_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl KPP_ROW2_SELECT_INPUT {
        const OFFSET: usize = 0x05c4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "LCD_BUSY_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct LCD_BUSY_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl LCD_BUSY_SELECT_INPUT {
        const OFFSET: usize = 0x05c8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI1_MCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI1_MCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI1_MCLK_SELECT_INPUT {
        const OFFSET: usize = 0x05cc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI1_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI1_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI1_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x05d0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI1_TX_BCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI1_TX_BCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI1_TX_BCLK_SELECT_INPUT {
        const OFFSET: usize = 0x05d4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI1_TX_SYNC_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI1_TX_SYNC_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI1_TX_SYNC_SELECT_INPUT {
        const OFFSET: usize = 0x05d8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI2_MCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI2_MCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI2_MCLK_SELECT_INPUT {
        const OFFSET: usize = 0x05dc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI2_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI2_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI2_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x05e0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI2_TX_BCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI2_TX_BCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI2_TX_BCLK_SELECT_INPUT {
        const OFFSET: usize = 0x05e4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI2_TX_SYNC_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI2_TX_SYNC_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI2_TX_SYNC_SELECT_INPUT {
        const OFFSET: usize = 0x05e8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI3_MCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI3_MCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI3_MCLK_SELECT_INPUT {
        const OFFSET: usize = 0x05ec;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI3_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI3_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI3_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x05f0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI3_TX_BCLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI3_TX_BCLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI3_TX_BCLK_SELECT_INPUT {
        const OFFSET: usize = 0x05f4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SAI3_TX_SYNC_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SAI3_TX_SYNC_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SAI3_TX_SYNC_SELECT_INPUT {
        const OFFSET: usize = 0x05f8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SDMA_EVENTS0_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SDMA_EVENTS0_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SDMA_EVENTS0_SELECT_INPUT {
        const OFFSET: usize = 0x05fc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SDMA_EVENTS1_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SDMA_EVENTS1_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SDMA_EVENTS1_SELECT_INPUT {
        const OFFSET: usize = 0x0600;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SPDIF_IN_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SPDIF_IN_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SPDIF_IN_SELECT_INPUT {
        const OFFSET: usize = 0x0604;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SPDIF_EXT_CLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct SPDIF_EXT_CLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SPDIF_EXT_CLK_SELECT_INPUT {
        const OFFSET: usize = 0x0608;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART1_RTS_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART1_RTS_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART1_RTS_B_SELECT_INPUT {
        const OFFSET: usize = 0x060c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART1_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART1_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART1_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x0610;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART2_RTS_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART2_RTS_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART2_RTS_B_SELECT_INPUT {
        const OFFSET: usize = 0x0614;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART2_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART2_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART2_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x0618;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART3_RTS_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART3_RTS_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART3_RTS_B_SELECT_INPUT {
        const OFFSET: usize = 0x061c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART3_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART3_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART3_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x0620;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART4_RTS_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART4_RTS_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART4_RTS_B_SELECT_INPUT {
        const OFFSET: usize = 0x0624;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART4_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART4_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART4_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x0628;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART5_RTS_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART5_RTS_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART5_RTS_B_SELECT_INPUT {
        const OFFSET: usize = 0x062c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART5_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART5_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART5_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x0630;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART6_RTS_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART6_RTS_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART6_RTS_B_SELECT_INPUT {
        const OFFSET: usize = 0x0634;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART6_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART6_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART6_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x0638;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART7_RTS_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART7_RTS_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART7_RTS_B_SELECT_INPUT {
        const OFFSET: usize = 0x063c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART7_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART7_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART7_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x0640;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART8_RTS_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART8_RTS_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART8_RTS_B_SELECT_INPUT {
        const OFFSET: usize = 0x0644;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "UART8_RX_DATA_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct UART8_RX_DATA_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl UART8_RX_DATA_SELECT_INPUT {
        const OFFSET: usize = 0x0648;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB_OTG2_OC_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USB_OTG2_OC_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB_OTG2_OC_SELECT_INPUT {
        const OFFSET: usize = 0x064c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB_OTG_OC_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USB_OTG_OC_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB_OTG_OC_SELECT_INPUT {
        const OFFSET: usize = 0x0650;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC1_CD_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC1_CD_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC1_CD_B_SELECT_INPUT {
        const OFFSET: usize = 0x0654;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC1_WP_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC1_WP_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC1_WP_SELECT_INPUT {
        const OFFSET: usize = 0x0658;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_CLK_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_CLK_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_CLK_SELECT_INPUT {
        const OFFSET: usize = 0x065c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_CD_B_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_CD_B_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_CD_B_SELECT_INPUT {
        const OFFSET: usize = 0x0660;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_CMD_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_CMD_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_CMD_SELECT_INPUT {
        const OFFSET: usize = 0x0664;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_DATA0_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_DATA0_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_DATA0_SELECT_INPUT {
        const OFFSET: usize = 0x0668;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_DATA1_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_DATA1_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_DATA1_SELECT_INPUT {
        const OFFSET: usize = 0x066c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_DATA2_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_DATA2_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_DATA2_SELECT_INPUT {
        const OFFSET: usize = 0x0670;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_DATA3_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_DATA3_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_DATA3_SELECT_INPUT {
        const OFFSET: usize = 0x0674;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_DATA4_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_DATA4_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_DATA4_SELECT_INPUT {
        const OFFSET: usize = 0x0678;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_DATA5_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_DATA5_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_DATA5_SELECT_INPUT {
        const OFFSET: usize = 0x067c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_DATA6_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_DATA6_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_DATA6_SELECT_INPUT {
        const OFFSET: usize = 0x0680;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_DATA7_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_DATA7_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_DATA7_SELECT_INPUT {
        const OFFSET: usize = 0x0684;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USDHC2_WP_SELECT_INPUT DAISY Register"]
    #[allow(non_camel_case_types)]
    pub struct USDHC2_WP_SELECT_INPUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USDHC2_WP_SELECT_INPUT {
        const OFFSET: usize = 0x0688;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                SW_MUX_CTL_PAD_BOOT_MODE0: SW_MUX_CTL_PAD_BOOT_MODE0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_BOOT_MODE1: SW_MUX_CTL_PAD_BOOT_MODE1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_MOD: SW_MUX_CTL_PAD_JTAG_MOD {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TMS: SW_MUX_CTL_PAD_JTAG_TMS {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TDO: SW_MUX_CTL_PAD_JTAG_TDO {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TDI: SW_MUX_CTL_PAD_JTAG_TDI {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TCK: SW_MUX_CTL_PAD_JTAG_TCK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TRST_B: SW_MUX_CTL_PAD_JTAG_TRST_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO00: SW_MUX_CTL_PAD_GPIO1_IO00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO01: SW_MUX_CTL_PAD_GPIO1_IO01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO02: SW_MUX_CTL_PAD_GPIO1_IO02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO03: SW_MUX_CTL_PAD_GPIO1_IO03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO04: SW_MUX_CTL_PAD_GPIO1_IO04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO05: SW_MUX_CTL_PAD_GPIO1_IO05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO06: SW_MUX_CTL_PAD_GPIO1_IO06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO07: SW_MUX_CTL_PAD_GPIO1_IO07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO08: SW_MUX_CTL_PAD_GPIO1_IO08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO09: SW_MUX_CTL_PAD_GPIO1_IO09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART1_CTS_B: SW_MUX_CTL_PAD_UART1_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART1_RTS_B: SW_MUX_CTL_PAD_UART1_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART2_CTS_B: SW_MUX_CTL_PAD_UART2_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART2_RTS_B: SW_MUX_CTL_PAD_UART2_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART3_CTS_B: SW_MUX_CTL_PAD_UART3_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART3_RTS_B: SW_MUX_CTL_PAD_UART3_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET1_RX_EN: SW_MUX_CTL_PAD_ENET1_RX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET1_TX_EN: SW_MUX_CTL_PAD_ENET1_TX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET1_TX_CLK: SW_MUX_CTL_PAD_ENET1_TX_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET1_RX_ER: SW_MUX_CTL_PAD_ENET1_RX_ER {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET2_RX_EN: SW_MUX_CTL_PAD_ENET2_RX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET2_TX_EN: SW_MUX_CTL_PAD_ENET2_TX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET2_TX_CLK: SW_MUX_CTL_PAD_ENET2_TX_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET2_RX_ER: SW_MUX_CTL_PAD_ENET2_RX_ER {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_CLK: SW_MUX_CTL_PAD_LCD_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_ENABLE: SW_MUX_CTL_PAD_LCD_ENABLE {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_HSYNC: SW_MUX_CTL_PAD_LCD_HSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_VSYNC: SW_MUX_CTL_PAD_LCD_VSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_RESET: SW_MUX_CTL_PAD_LCD_RESET {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA00: SW_MUX_CTL_PAD_LCD_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA01: SW_MUX_CTL_PAD_LCD_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA02: SW_MUX_CTL_PAD_LCD_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA03: SW_MUX_CTL_PAD_LCD_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA04: SW_MUX_CTL_PAD_LCD_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA05: SW_MUX_CTL_PAD_LCD_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA06: SW_MUX_CTL_PAD_LCD_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA07: SW_MUX_CTL_PAD_LCD_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA08: SW_MUX_CTL_PAD_LCD_DATA08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA09: SW_MUX_CTL_PAD_LCD_DATA09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA10: SW_MUX_CTL_PAD_LCD_DATA10 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA11: SW_MUX_CTL_PAD_LCD_DATA11 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA12: SW_MUX_CTL_PAD_LCD_DATA12 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA13: SW_MUX_CTL_PAD_LCD_DATA13 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA14: SW_MUX_CTL_PAD_LCD_DATA14 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA15: SW_MUX_CTL_PAD_LCD_DATA15 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA16: SW_MUX_CTL_PAD_LCD_DATA16 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA17: SW_MUX_CTL_PAD_LCD_DATA17 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA18: SW_MUX_CTL_PAD_LCD_DATA18 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA19: SW_MUX_CTL_PAD_LCD_DATA19 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA20: SW_MUX_CTL_PAD_LCD_DATA20 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA21: SW_MUX_CTL_PAD_LCD_DATA21 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA22: SW_MUX_CTL_PAD_LCD_DATA22 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA23: SW_MUX_CTL_PAD_LCD_DATA23 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_RE_B: SW_MUX_CTL_PAD_NAND_RE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_WE_B: SW_MUX_CTL_PAD_NAND_WE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA00: SW_MUX_CTL_PAD_NAND_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA01: SW_MUX_CTL_PAD_NAND_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA02: SW_MUX_CTL_PAD_NAND_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA03: SW_MUX_CTL_PAD_NAND_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA04: SW_MUX_CTL_PAD_NAND_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA05: SW_MUX_CTL_PAD_NAND_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA06: SW_MUX_CTL_PAD_NAND_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA07: SW_MUX_CTL_PAD_NAND_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_ALE: SW_MUX_CTL_PAD_NAND_ALE {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_WP_B: SW_MUX_CTL_PAD_NAND_WP_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_CE0_B: SW_MUX_CTL_PAD_NAND_CE0_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_CE1_B: SW_MUX_CTL_PAD_NAND_CE1_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_CLE: SW_MUX_CTL_PAD_NAND_CLE {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DQS: SW_MUX_CTL_PAD_NAND_DQS {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_CMD: SW_MUX_CTL_PAD_SD1_CMD {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_CLK: SW_MUX_CTL_PAD_SD1_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_DATA0: SW_MUX_CTL_PAD_SD1_DATA0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_DATA1: SW_MUX_CTL_PAD_SD1_DATA1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_DATA2: SW_MUX_CTL_PAD_SD1_DATA2 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_DATA3: SW_MUX_CTL_PAD_SD1_DATA3 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_MCLK: SW_MUX_CTL_PAD_CSI_MCLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_PIXCLK: SW_MUX_CTL_PAD_CSI_PIXCLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_VSYNC: SW_MUX_CTL_PAD_CSI_VSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_HSYNC: SW_MUX_CTL_PAD_CSI_HSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA00: SW_MUX_CTL_PAD_CSI_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA01: SW_MUX_CTL_PAD_CSI_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA02: SW_MUX_CTL_PAD_CSI_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA03: SW_MUX_CTL_PAD_CSI_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA04: SW_MUX_CTL_PAD_CSI_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA05: SW_MUX_CTL_PAD_CSI_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA06: SW_MUX_CTL_PAD_CSI_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA07: SW_MUX_CTL_PAD_CSI_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR00: SW_PAD_CTL_PAD_DRAM_ADDR00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR01: SW_PAD_CTL_PAD_DRAM_ADDR01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR02: SW_PAD_CTL_PAD_DRAM_ADDR02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR03: SW_PAD_CTL_PAD_DRAM_ADDR03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR04: SW_PAD_CTL_PAD_DRAM_ADDR04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR05: SW_PAD_CTL_PAD_DRAM_ADDR05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR06: SW_PAD_CTL_PAD_DRAM_ADDR06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR07: SW_PAD_CTL_PAD_DRAM_ADDR07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR08: SW_PAD_CTL_PAD_DRAM_ADDR08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR09: SW_PAD_CTL_PAD_DRAM_ADDR09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR10: SW_PAD_CTL_PAD_DRAM_ADDR10 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR11: SW_PAD_CTL_PAD_DRAM_ADDR11 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR12: SW_PAD_CTL_PAD_DRAM_ADDR12 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR13: SW_PAD_CTL_PAD_DRAM_ADDR13 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR14: SW_PAD_CTL_PAD_DRAM_ADDR14 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR15: SW_PAD_CTL_PAD_DRAM_ADDR15 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_DQM0: SW_PAD_CTL_PAD_DRAM_DQM0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_DQM1: SW_PAD_CTL_PAD_DRAM_DQM1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_RAS_B: SW_PAD_CTL_PAD_DRAM_RAS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_CAS_B: SW_PAD_CTL_PAD_DRAM_CAS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_CS0_B: SW_PAD_CTL_PAD_DRAM_CS0_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_CS1_B: SW_PAD_CTL_PAD_DRAM_CS1_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDWE_B: SW_PAD_CTL_PAD_DRAM_SDWE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ODT0: SW_PAD_CTL_PAD_DRAM_ODT0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ODT1: SW_PAD_CTL_PAD_DRAM_ODT1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDBA0: SW_PAD_CTL_PAD_DRAM_SDBA0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDBA1: SW_PAD_CTL_PAD_DRAM_SDBA1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDBA2: SW_PAD_CTL_PAD_DRAM_SDBA2 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDCKE0: SW_PAD_CTL_PAD_DRAM_SDCKE0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDCKE1: SW_PAD_CTL_PAD_DRAM_SDCKE1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_RESET: SW_PAD_CTL_PAD_DRAM_RESET {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_TEST_MODE: SW_PAD_CTL_PAD_TEST_MODE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_POR_B: SW_PAD_CTL_PAD_POR_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ONOFF: SW_PAD_CTL_PAD_ONOFF {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_BOOT_MODE0: SW_PAD_CTL_PAD_BOOT_MODE0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_BOOT_MODE1: SW_PAD_CTL_PAD_BOOT_MODE1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_MOD: SW_PAD_CTL_PAD_JTAG_MOD {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TMS: SW_PAD_CTL_PAD_JTAG_TMS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TDO: SW_PAD_CTL_PAD_JTAG_TDO {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TDI: SW_PAD_CTL_PAD_JTAG_TDI {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TCK: SW_PAD_CTL_PAD_JTAG_TCK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TRST_B: SW_PAD_CTL_PAD_JTAG_TRST_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO00: SW_PAD_CTL_PAD_GPIO1_IO00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO01: SW_PAD_CTL_PAD_GPIO1_IO01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO02: SW_PAD_CTL_PAD_GPIO1_IO02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO03: SW_PAD_CTL_PAD_GPIO1_IO03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO04: SW_PAD_CTL_PAD_GPIO1_IO04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO05: SW_PAD_CTL_PAD_GPIO1_IO05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO06: SW_PAD_CTL_PAD_GPIO1_IO06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO07: SW_PAD_CTL_PAD_GPIO1_IO07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO08: SW_PAD_CTL_PAD_GPIO1_IO08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO09: SW_PAD_CTL_PAD_GPIO1_IO09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART1_CTS_B: SW_PAD_CTL_PAD_UART1_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART1_RTS_B: SW_PAD_CTL_PAD_UART1_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART2_CTS_B: SW_PAD_CTL_PAD_UART2_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART2_RTS_B: SW_PAD_CTL_PAD_UART2_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART3_CTS_B: SW_PAD_CTL_PAD_UART3_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART3_RTS_B: SW_PAD_CTL_PAD_UART3_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET1_RX_EN: SW_PAD_CTL_PAD_ENET1_RX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET1_TX_EN: SW_PAD_CTL_PAD_ENET1_TX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET1_TX_CLK: SW_PAD_CTL_PAD_ENET1_TX_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET1_RX_ER: SW_PAD_CTL_PAD_ENET1_RX_ER {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET2_RX_EN: SW_PAD_CTL_PAD_ENET2_RX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET2_TX_EN: SW_PAD_CTL_PAD_ENET2_TX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET2_TX_CLK: SW_PAD_CTL_PAD_ENET2_TX_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET2_RX_ER: SW_PAD_CTL_PAD_ENET2_RX_ER {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_CLK: SW_PAD_CTL_PAD_LCD_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_ENABLE: SW_PAD_CTL_PAD_LCD_ENABLE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_HSYNC: SW_PAD_CTL_PAD_LCD_HSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_VSYNC: SW_PAD_CTL_PAD_LCD_VSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_RESET: SW_PAD_CTL_PAD_LCD_RESET {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA00: SW_PAD_CTL_PAD_LCD_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA01: SW_PAD_CTL_PAD_LCD_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA02: SW_PAD_CTL_PAD_LCD_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA03: SW_PAD_CTL_PAD_LCD_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA04: SW_PAD_CTL_PAD_LCD_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA05: SW_PAD_CTL_PAD_LCD_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA06: SW_PAD_CTL_PAD_LCD_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA07: SW_PAD_CTL_PAD_LCD_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA08: SW_PAD_CTL_PAD_LCD_DATA08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA09: SW_PAD_CTL_PAD_LCD_DATA09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA10: SW_PAD_CTL_PAD_LCD_DATA10 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA11: SW_PAD_CTL_PAD_LCD_DATA11 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA12: SW_PAD_CTL_PAD_LCD_DATA12 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA13: SW_PAD_CTL_PAD_LCD_DATA13 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA14: SW_PAD_CTL_PAD_LCD_DATA14 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA15: SW_PAD_CTL_PAD_LCD_DATA15 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA16: SW_PAD_CTL_PAD_LCD_DATA16 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA17: SW_PAD_CTL_PAD_LCD_DATA17 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA18: SW_PAD_CTL_PAD_LCD_DATA18 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA19: SW_PAD_CTL_PAD_LCD_DATA19 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA20: SW_PAD_CTL_PAD_LCD_DATA20 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA21: SW_PAD_CTL_PAD_LCD_DATA21 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA22: SW_PAD_CTL_PAD_LCD_DATA22 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA23: SW_PAD_CTL_PAD_LCD_DATA23 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_RE_B: SW_PAD_CTL_PAD_NAND_RE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_WE_B: SW_PAD_CTL_PAD_NAND_WE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA00: SW_PAD_CTL_PAD_NAND_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA01: SW_PAD_CTL_PAD_NAND_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA02: SW_PAD_CTL_PAD_NAND_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA03: SW_PAD_CTL_PAD_NAND_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA04: SW_PAD_CTL_PAD_NAND_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA05: SW_PAD_CTL_PAD_NAND_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA06: SW_PAD_CTL_PAD_NAND_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA07: SW_PAD_CTL_PAD_NAND_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_ALE: SW_PAD_CTL_PAD_NAND_ALE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_WP_B: SW_PAD_CTL_PAD_NAND_WP_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_CE0_B: SW_PAD_CTL_PAD_NAND_CE0_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_CE1_B: SW_PAD_CTL_PAD_NAND_CE1_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_CLE: SW_PAD_CTL_PAD_NAND_CLE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DQS: SW_PAD_CTL_PAD_NAND_DQS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_CMD: SW_PAD_CTL_PAD_SD1_CMD {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_CLK: SW_PAD_CTL_PAD_SD1_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_DATA0: SW_PAD_CTL_PAD_SD1_DATA0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_DATA1: SW_PAD_CTL_PAD_SD1_DATA1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_DATA2: SW_PAD_CTL_PAD_SD1_DATA2 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_DATA3: SW_PAD_CTL_PAD_SD1_DATA3 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_MCLK: SW_PAD_CTL_PAD_CSI_MCLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_PIXCLK: SW_PAD_CTL_PAD_CSI_PIXCLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_VSYNC: SW_PAD_CTL_PAD_CSI_VSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_HSYNC: SW_PAD_CTL_PAD_CSI_HSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA00: SW_PAD_CTL_PAD_CSI_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA01: SW_PAD_CTL_PAD_CSI_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA02: SW_PAD_CTL_PAD_CSI_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA03: SW_PAD_CTL_PAD_CSI_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA04: SW_PAD_CTL_PAD_CSI_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA05: SW_PAD_CTL_PAD_CSI_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA06: SW_PAD_CTL_PAD_CSI_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA07: SW_PAD_CTL_PAD_CSI_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_ADDDS: SW_PAD_CTL_GRP_ADDDS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRMODE_CTL: SW_PAD_CTL_GRP_DDRMODE_CTL {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_B0DS: SW_PAD_CTL_GRP_B0DS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRPK: SW_PAD_CTL_GRP_DDRPK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_CTLDS: SW_PAD_CTL_GRP_CTLDS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_B1DS: SW_PAD_CTL_GRP_B1DS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRHYS: SW_PAD_CTL_GRP_DDRHYS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRPKE: SW_PAD_CTL_GRP_DDRPKE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRMODE: SW_PAD_CTL_GRP_DDRMODE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDR_TYPE: SW_PAD_CTL_GRP_DDR_TYPE {
                    _not_send_or_sync: PhantomData,
                },
                USB_OTG1_ID_SELECT_INPUT: USB_OTG1_ID_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USB_OTG2_ID_SELECT_INPUT: USB_OTG2_ID_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CCM_PMIC_READY_SELECT_INPUT: CCM_PMIC_READY_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA02_SELECT_INPUT: CSI_DATA02_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA03_SELECT_INPUT: CSI_DATA03_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA05_SELECT_INPUT: CSI_DATA05_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA00_SELECT_INPUT: CSI_DATA00_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA01_SELECT_INPUT: CSI_DATA01_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA04_SELECT_INPUT: CSI_DATA04_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA06_SELECT_INPUT: CSI_DATA06_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA07_SELECT_INPUT: CSI_DATA07_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA08_SELECT_INPUT: CSI_DATA08_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA09_SELECT_INPUT: CSI_DATA09_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA10_SELECT_INPUT: CSI_DATA10_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA11_SELECT_INPUT: CSI_DATA11_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA12_SELECT_INPUT: CSI_DATA12_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA13_SELECT_INPUT: CSI_DATA13_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA14_SELECT_INPUT: CSI_DATA14_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA15_SELECT_INPUT: CSI_DATA15_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA16_SELECT_INPUT: CSI_DATA16_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA17_SELECT_INPUT: CSI_DATA17_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA18_SELECT_INPUT: CSI_DATA18_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA19_SELECT_INPUT: CSI_DATA19_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA20_SELECT_INPUT: CSI_DATA20_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA21_SELECT_INPUT: CSI_DATA21_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA22_SELECT_INPUT: CSI_DATA22_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA23_SELECT_INPUT: CSI_DATA23_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_HSYNC_SELECT_INPUT: CSI_HSYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_PIXCLK_SELECT_INPUT: CSI_PIXCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_VSYNC_SELECT_INPUT: CSI_VSYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_FIELD_SELECT_INPUT: CSI_FIELD_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI1_SCLK_SELECT_INPUT: ECSPI1_SCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI1_MISO_SELECT_INPUT: ECSPI1_MISO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI1_MOSI_SELECT_INPUT: ECSPI1_MOSI_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI1_SS0_B_SELECT_INPUT: ECSPI1_SS0_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI2_SCLK_SELECT_INPUT: ECSPI2_SCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI2_MISO_SELECT_INPUT: ECSPI2_MISO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI2_MOSI_SELECT_INPUT: ECSPI2_MOSI_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI2_SS0_B_SELECT_INPUT: ECSPI2_SS0_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI3_SCLK_SELECT_INPUT: ECSPI3_SCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI3_MISO_SELECT_INPUT: ECSPI3_MISO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI3_MOSI_SELECT_INPUT: ECSPI3_MOSI_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI3_SS0_B_SELECT_INPUT: ECSPI3_SS0_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI4_SCLK_SELECT_INPUT: ECSPI4_SCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI4_MISO_SELECT_INPUT: ECSPI4_MISO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI4_MOSI_SELECT_INPUT: ECSPI4_MOSI_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI4_SS0_B_SELECT_INPUT: ECSPI4_SS0_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ENET1_REF_CLK1_SELECT_INPUT: ENET1_REF_CLK1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ENET1_MAC0_MDIO_SELECT_INPUT: ENET1_MAC0_MDIO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ENET2_REF_CLK2_SELECT_INPUT: ENET2_REF_CLK2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ENET2_MAC0_MDIO_SELECT_INPUT: ENET2_MAC0_MDIO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                FLEXCAN1_RX_SELECT_INPUT: FLEXCAN1_RX_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                FLEXCAN2_RX_SELECT_INPUT: FLEXCAN2_RX_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT1_CAPTURE1_SELECT_INPUT: GPT1_CAPTURE1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT1_CAPTURE2_SELECT_INPUT: GPT1_CAPTURE2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT1_CLK_SELECT_INPUT: GPT1_CLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT2_CAPTURE1_SELECT_INPUT: GPT2_CAPTURE1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT2_CAPTURE2_SELECT_INPUT: GPT2_CAPTURE2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT2_CLK_SELECT_INPUT: GPT2_CLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C1_SCL_SELECT_INPUT: I2C1_SCL_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C1_SDA_SELECT_INPUT: I2C1_SDA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C2_SCL_SELECT_INPUT: I2C2_SCL_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C2_SDA_SELECT_INPUT: I2C2_SDA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C3_SCL_SELECT_INPUT: I2C3_SCL_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C3_SDA_SELECT_INPUT: I2C3_SDA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C4_SCL_SELECT_INPUT: I2C4_SCL_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C4_SDA_SELECT_INPUT: I2C4_SDA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_COL0_SELECT_INPUT: KPP_COL0_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_COL1_SELECT_INPUT: KPP_COL1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_COL2_SELECT_INPUT: KPP_COL2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_ROW0_SELECT_INPUT: KPP_ROW0_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_ROW1_SELECT_INPUT: KPP_ROW1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_ROW2_SELECT_INPUT: KPP_ROW2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                LCD_BUSY_SELECT_INPUT: LCD_BUSY_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI1_MCLK_SELECT_INPUT: SAI1_MCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI1_RX_DATA_SELECT_INPUT: SAI1_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI1_TX_BCLK_SELECT_INPUT: SAI1_TX_BCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI1_TX_SYNC_SELECT_INPUT: SAI1_TX_SYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI2_MCLK_SELECT_INPUT: SAI2_MCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI2_RX_DATA_SELECT_INPUT: SAI2_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI2_TX_BCLK_SELECT_INPUT: SAI2_TX_BCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI2_TX_SYNC_SELECT_INPUT: SAI2_TX_SYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI3_MCLK_SELECT_INPUT: SAI3_MCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI3_RX_DATA_SELECT_INPUT: SAI3_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI3_TX_BCLK_SELECT_INPUT: SAI3_TX_BCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI3_TX_SYNC_SELECT_INPUT: SAI3_TX_SYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SDMA_EVENTS0_SELECT_INPUT: SDMA_EVENTS0_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SDMA_EVENTS1_SELECT_INPUT: SDMA_EVENTS1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SPDIF_IN_SELECT_INPUT: SPDIF_IN_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SPDIF_EXT_CLK_SELECT_INPUT: SPDIF_EXT_CLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART1_RTS_B_SELECT_INPUT: UART1_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART1_RX_DATA_SELECT_INPUT: UART1_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART2_RTS_B_SELECT_INPUT: UART2_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART2_RX_DATA_SELECT_INPUT: UART2_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART3_RTS_B_SELECT_INPUT: UART3_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART3_RX_DATA_SELECT_INPUT: UART3_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART4_RTS_B_SELECT_INPUT: UART4_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART4_RX_DATA_SELECT_INPUT: UART4_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART5_RTS_B_SELECT_INPUT: UART5_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART5_RX_DATA_SELECT_INPUT: UART5_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART6_RTS_B_SELECT_INPUT: UART6_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART6_RX_DATA_SELECT_INPUT: UART6_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART7_RTS_B_SELECT_INPUT: UART7_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART7_RX_DATA_SELECT_INPUT: UART7_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART8_RTS_B_SELECT_INPUT: UART8_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART8_RX_DATA_SELECT_INPUT: UART8_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USB_OTG2_OC_SELECT_INPUT: USB_OTG2_OC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USB_OTG_OC_SELECT_INPUT: USB_OTG_OC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC1_CD_B_SELECT_INPUT: USDHC1_CD_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC1_WP_SELECT_INPUT: USDHC1_WP_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_CLK_SELECT_INPUT: USDHC2_CLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_CD_B_SELECT_INPUT: USDHC2_CD_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_CMD_SELECT_INPUT: USDHC2_CMD_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA0_SELECT_INPUT: USDHC2_DATA0_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA1_SELECT_INPUT: USDHC2_DATA1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA2_SELECT_INPUT: USDHC2_DATA2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA3_SELECT_INPUT: USDHC2_DATA3_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA4_SELECT_INPUT: USDHC2_DATA4_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA5_SELECT_INPUT: USDHC2_DATA5_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA6_SELECT_INPUT: USDHC2_DATA6_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA7_SELECT_INPUT: USDHC2_DATA7_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_WP_SELECT_INPUT: USDHC2_WP_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "IOMUXC"]
    pub type IOMUXC = Registers;
    impl IOMUXC {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                SW_MUX_CTL_PAD_BOOT_MODE0: SW_MUX_CTL_PAD_BOOT_MODE0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_BOOT_MODE1: SW_MUX_CTL_PAD_BOOT_MODE1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_MOD: SW_MUX_CTL_PAD_JTAG_MOD {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TMS: SW_MUX_CTL_PAD_JTAG_TMS {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TDO: SW_MUX_CTL_PAD_JTAG_TDO {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TDI: SW_MUX_CTL_PAD_JTAG_TDI {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TCK: SW_MUX_CTL_PAD_JTAG_TCK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_JTAG_TRST_B: SW_MUX_CTL_PAD_JTAG_TRST_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO00: SW_MUX_CTL_PAD_GPIO1_IO00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO01: SW_MUX_CTL_PAD_GPIO1_IO01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO02: SW_MUX_CTL_PAD_GPIO1_IO02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO03: SW_MUX_CTL_PAD_GPIO1_IO03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO04: SW_MUX_CTL_PAD_GPIO1_IO04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO05: SW_MUX_CTL_PAD_GPIO1_IO05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO06: SW_MUX_CTL_PAD_GPIO1_IO06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO07: SW_MUX_CTL_PAD_GPIO1_IO07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO08: SW_MUX_CTL_PAD_GPIO1_IO08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_GPIO1_IO09: SW_MUX_CTL_PAD_GPIO1_IO09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART1_CTS_B: SW_MUX_CTL_PAD_UART1_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART1_RTS_B: SW_MUX_CTL_PAD_UART1_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART2_CTS_B: SW_MUX_CTL_PAD_UART2_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART2_RTS_B: SW_MUX_CTL_PAD_UART2_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART3_CTS_B: SW_MUX_CTL_PAD_UART3_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_UART3_RTS_B: SW_MUX_CTL_PAD_UART3_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET1_RX_EN: SW_MUX_CTL_PAD_ENET1_RX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET1_TX_EN: SW_MUX_CTL_PAD_ENET1_TX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET1_TX_CLK: SW_MUX_CTL_PAD_ENET1_TX_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET1_RX_ER: SW_MUX_CTL_PAD_ENET1_RX_ER {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET2_RX_EN: SW_MUX_CTL_PAD_ENET2_RX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET2_TX_EN: SW_MUX_CTL_PAD_ENET2_TX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET2_TX_CLK: SW_MUX_CTL_PAD_ENET2_TX_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_ENET2_RX_ER: SW_MUX_CTL_PAD_ENET2_RX_ER {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_CLK: SW_MUX_CTL_PAD_LCD_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_ENABLE: SW_MUX_CTL_PAD_LCD_ENABLE {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_HSYNC: SW_MUX_CTL_PAD_LCD_HSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_VSYNC: SW_MUX_CTL_PAD_LCD_VSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_RESET: SW_MUX_CTL_PAD_LCD_RESET {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA00: SW_MUX_CTL_PAD_LCD_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA01: SW_MUX_CTL_PAD_LCD_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA02: SW_MUX_CTL_PAD_LCD_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA03: SW_MUX_CTL_PAD_LCD_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA04: SW_MUX_CTL_PAD_LCD_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA05: SW_MUX_CTL_PAD_LCD_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA06: SW_MUX_CTL_PAD_LCD_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA07: SW_MUX_CTL_PAD_LCD_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA08: SW_MUX_CTL_PAD_LCD_DATA08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA09: SW_MUX_CTL_PAD_LCD_DATA09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA10: SW_MUX_CTL_PAD_LCD_DATA10 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA11: SW_MUX_CTL_PAD_LCD_DATA11 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA12: SW_MUX_CTL_PAD_LCD_DATA12 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA13: SW_MUX_CTL_PAD_LCD_DATA13 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA14: SW_MUX_CTL_PAD_LCD_DATA14 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA15: SW_MUX_CTL_PAD_LCD_DATA15 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA16: SW_MUX_CTL_PAD_LCD_DATA16 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA17: SW_MUX_CTL_PAD_LCD_DATA17 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA18: SW_MUX_CTL_PAD_LCD_DATA18 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA19: SW_MUX_CTL_PAD_LCD_DATA19 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA20: SW_MUX_CTL_PAD_LCD_DATA20 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA21: SW_MUX_CTL_PAD_LCD_DATA21 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA22: SW_MUX_CTL_PAD_LCD_DATA22 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_LCD_DATA23: SW_MUX_CTL_PAD_LCD_DATA23 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_RE_B: SW_MUX_CTL_PAD_NAND_RE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_WE_B: SW_MUX_CTL_PAD_NAND_WE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA00: SW_MUX_CTL_PAD_NAND_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA01: SW_MUX_CTL_PAD_NAND_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA02: SW_MUX_CTL_PAD_NAND_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA03: SW_MUX_CTL_PAD_NAND_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA04: SW_MUX_CTL_PAD_NAND_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA05: SW_MUX_CTL_PAD_NAND_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA06: SW_MUX_CTL_PAD_NAND_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DATA07: SW_MUX_CTL_PAD_NAND_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_ALE: SW_MUX_CTL_PAD_NAND_ALE {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_WP_B: SW_MUX_CTL_PAD_NAND_WP_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_CE0_B: SW_MUX_CTL_PAD_NAND_CE0_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_CE1_B: SW_MUX_CTL_PAD_NAND_CE1_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_CLE: SW_MUX_CTL_PAD_NAND_CLE {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_NAND_DQS: SW_MUX_CTL_PAD_NAND_DQS {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_CMD: SW_MUX_CTL_PAD_SD1_CMD {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_CLK: SW_MUX_CTL_PAD_SD1_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_DATA0: SW_MUX_CTL_PAD_SD1_DATA0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_DATA1: SW_MUX_CTL_PAD_SD1_DATA1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_DATA2: SW_MUX_CTL_PAD_SD1_DATA2 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_SD1_DATA3: SW_MUX_CTL_PAD_SD1_DATA3 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_MCLK: SW_MUX_CTL_PAD_CSI_MCLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_PIXCLK: SW_MUX_CTL_PAD_CSI_PIXCLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_VSYNC: SW_MUX_CTL_PAD_CSI_VSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_HSYNC: SW_MUX_CTL_PAD_CSI_HSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA00: SW_MUX_CTL_PAD_CSI_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA01: SW_MUX_CTL_PAD_CSI_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA02: SW_MUX_CTL_PAD_CSI_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA03: SW_MUX_CTL_PAD_CSI_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA04: SW_MUX_CTL_PAD_CSI_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA05: SW_MUX_CTL_PAD_CSI_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA06: SW_MUX_CTL_PAD_CSI_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_MUX_CTL_PAD_CSI_DATA07: SW_MUX_CTL_PAD_CSI_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR00: SW_PAD_CTL_PAD_DRAM_ADDR00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR01: SW_PAD_CTL_PAD_DRAM_ADDR01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR02: SW_PAD_CTL_PAD_DRAM_ADDR02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR03: SW_PAD_CTL_PAD_DRAM_ADDR03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR04: SW_PAD_CTL_PAD_DRAM_ADDR04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR05: SW_PAD_CTL_PAD_DRAM_ADDR05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR06: SW_PAD_CTL_PAD_DRAM_ADDR06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR07: SW_PAD_CTL_PAD_DRAM_ADDR07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR08: SW_PAD_CTL_PAD_DRAM_ADDR08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR09: SW_PAD_CTL_PAD_DRAM_ADDR09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR10: SW_PAD_CTL_PAD_DRAM_ADDR10 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR11: SW_PAD_CTL_PAD_DRAM_ADDR11 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR12: SW_PAD_CTL_PAD_DRAM_ADDR12 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR13: SW_PAD_CTL_PAD_DRAM_ADDR13 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR14: SW_PAD_CTL_PAD_DRAM_ADDR14 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ADDR15: SW_PAD_CTL_PAD_DRAM_ADDR15 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_DQM0: SW_PAD_CTL_PAD_DRAM_DQM0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_DQM1: SW_PAD_CTL_PAD_DRAM_DQM1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_RAS_B: SW_PAD_CTL_PAD_DRAM_RAS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_CAS_B: SW_PAD_CTL_PAD_DRAM_CAS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_CS0_B: SW_PAD_CTL_PAD_DRAM_CS0_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_CS1_B: SW_PAD_CTL_PAD_DRAM_CS1_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDWE_B: SW_PAD_CTL_PAD_DRAM_SDWE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ODT0: SW_PAD_CTL_PAD_DRAM_ODT0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_ODT1: SW_PAD_CTL_PAD_DRAM_ODT1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDBA0: SW_PAD_CTL_PAD_DRAM_SDBA0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDBA1: SW_PAD_CTL_PAD_DRAM_SDBA1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDBA2: SW_PAD_CTL_PAD_DRAM_SDBA2 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDCKE0: SW_PAD_CTL_PAD_DRAM_SDCKE0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_SDCKE1: SW_PAD_CTL_PAD_DRAM_SDCKE1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_DRAM_RESET: SW_PAD_CTL_PAD_DRAM_RESET {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_TEST_MODE: SW_PAD_CTL_PAD_TEST_MODE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_POR_B: SW_PAD_CTL_PAD_POR_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ONOFF: SW_PAD_CTL_PAD_ONOFF {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_BOOT_MODE0: SW_PAD_CTL_PAD_BOOT_MODE0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_BOOT_MODE1: SW_PAD_CTL_PAD_BOOT_MODE1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_MOD: SW_PAD_CTL_PAD_JTAG_MOD {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TMS: SW_PAD_CTL_PAD_JTAG_TMS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TDO: SW_PAD_CTL_PAD_JTAG_TDO {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TDI: SW_PAD_CTL_PAD_JTAG_TDI {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TCK: SW_PAD_CTL_PAD_JTAG_TCK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_JTAG_TRST_B: SW_PAD_CTL_PAD_JTAG_TRST_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO00: SW_PAD_CTL_PAD_GPIO1_IO00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO01: SW_PAD_CTL_PAD_GPIO1_IO01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO02: SW_PAD_CTL_PAD_GPIO1_IO02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO03: SW_PAD_CTL_PAD_GPIO1_IO03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO04: SW_PAD_CTL_PAD_GPIO1_IO04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO05: SW_PAD_CTL_PAD_GPIO1_IO05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO06: SW_PAD_CTL_PAD_GPIO1_IO06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO07: SW_PAD_CTL_PAD_GPIO1_IO07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO08: SW_PAD_CTL_PAD_GPIO1_IO08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_GPIO1_IO09: SW_PAD_CTL_PAD_GPIO1_IO09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART1_CTS_B: SW_PAD_CTL_PAD_UART1_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART1_RTS_B: SW_PAD_CTL_PAD_UART1_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART2_CTS_B: SW_PAD_CTL_PAD_UART2_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART2_RTS_B: SW_PAD_CTL_PAD_UART2_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART3_CTS_B: SW_PAD_CTL_PAD_UART3_CTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_UART3_RTS_B: SW_PAD_CTL_PAD_UART3_RTS_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET1_RX_EN: SW_PAD_CTL_PAD_ENET1_RX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET1_TX_EN: SW_PAD_CTL_PAD_ENET1_TX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET1_TX_CLK: SW_PAD_CTL_PAD_ENET1_TX_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET1_RX_ER: SW_PAD_CTL_PAD_ENET1_RX_ER {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET2_RX_EN: SW_PAD_CTL_PAD_ENET2_RX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET2_TX_EN: SW_PAD_CTL_PAD_ENET2_TX_EN {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET2_TX_CLK: SW_PAD_CTL_PAD_ENET2_TX_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_ENET2_RX_ER: SW_PAD_CTL_PAD_ENET2_RX_ER {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_CLK: SW_PAD_CTL_PAD_LCD_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_ENABLE: SW_PAD_CTL_PAD_LCD_ENABLE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_HSYNC: SW_PAD_CTL_PAD_LCD_HSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_VSYNC: SW_PAD_CTL_PAD_LCD_VSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_RESET: SW_PAD_CTL_PAD_LCD_RESET {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA00: SW_PAD_CTL_PAD_LCD_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA01: SW_PAD_CTL_PAD_LCD_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA02: SW_PAD_CTL_PAD_LCD_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA03: SW_PAD_CTL_PAD_LCD_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA04: SW_PAD_CTL_PAD_LCD_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA05: SW_PAD_CTL_PAD_LCD_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA06: SW_PAD_CTL_PAD_LCD_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA07: SW_PAD_CTL_PAD_LCD_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA08: SW_PAD_CTL_PAD_LCD_DATA08 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA09: SW_PAD_CTL_PAD_LCD_DATA09 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA10: SW_PAD_CTL_PAD_LCD_DATA10 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA11: SW_PAD_CTL_PAD_LCD_DATA11 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA12: SW_PAD_CTL_PAD_LCD_DATA12 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA13: SW_PAD_CTL_PAD_LCD_DATA13 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA14: SW_PAD_CTL_PAD_LCD_DATA14 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA15: SW_PAD_CTL_PAD_LCD_DATA15 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA16: SW_PAD_CTL_PAD_LCD_DATA16 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA17: SW_PAD_CTL_PAD_LCD_DATA17 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA18: SW_PAD_CTL_PAD_LCD_DATA18 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA19: SW_PAD_CTL_PAD_LCD_DATA19 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA20: SW_PAD_CTL_PAD_LCD_DATA20 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA21: SW_PAD_CTL_PAD_LCD_DATA21 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA22: SW_PAD_CTL_PAD_LCD_DATA22 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_LCD_DATA23: SW_PAD_CTL_PAD_LCD_DATA23 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_RE_B: SW_PAD_CTL_PAD_NAND_RE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_WE_B: SW_PAD_CTL_PAD_NAND_WE_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA00: SW_PAD_CTL_PAD_NAND_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA01: SW_PAD_CTL_PAD_NAND_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA02: SW_PAD_CTL_PAD_NAND_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA03: SW_PAD_CTL_PAD_NAND_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA04: SW_PAD_CTL_PAD_NAND_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA05: SW_PAD_CTL_PAD_NAND_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA06: SW_PAD_CTL_PAD_NAND_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DATA07: SW_PAD_CTL_PAD_NAND_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_ALE: SW_PAD_CTL_PAD_NAND_ALE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_WP_B: SW_PAD_CTL_PAD_NAND_WP_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_CE0_B: SW_PAD_CTL_PAD_NAND_CE0_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_CE1_B: SW_PAD_CTL_PAD_NAND_CE1_B {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_CLE: SW_PAD_CTL_PAD_NAND_CLE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_NAND_DQS: SW_PAD_CTL_PAD_NAND_DQS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_CMD: SW_PAD_CTL_PAD_SD1_CMD {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_CLK: SW_PAD_CTL_PAD_SD1_CLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_DATA0: SW_PAD_CTL_PAD_SD1_DATA0 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_DATA1: SW_PAD_CTL_PAD_SD1_DATA1 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_DATA2: SW_PAD_CTL_PAD_SD1_DATA2 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_SD1_DATA3: SW_PAD_CTL_PAD_SD1_DATA3 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_MCLK: SW_PAD_CTL_PAD_CSI_MCLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_PIXCLK: SW_PAD_CTL_PAD_CSI_PIXCLK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_VSYNC: SW_PAD_CTL_PAD_CSI_VSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_HSYNC: SW_PAD_CTL_PAD_CSI_HSYNC {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA00: SW_PAD_CTL_PAD_CSI_DATA00 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA01: SW_PAD_CTL_PAD_CSI_DATA01 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA02: SW_PAD_CTL_PAD_CSI_DATA02 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA03: SW_PAD_CTL_PAD_CSI_DATA03 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA04: SW_PAD_CTL_PAD_CSI_DATA04 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA05: SW_PAD_CTL_PAD_CSI_DATA05 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA06: SW_PAD_CTL_PAD_CSI_DATA06 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_PAD_CSI_DATA07: SW_PAD_CTL_PAD_CSI_DATA07 {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_ADDDS: SW_PAD_CTL_GRP_ADDDS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRMODE_CTL: SW_PAD_CTL_GRP_DDRMODE_CTL {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_B0DS: SW_PAD_CTL_GRP_B0DS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRPK: SW_PAD_CTL_GRP_DDRPK {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_CTLDS: SW_PAD_CTL_GRP_CTLDS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_B1DS: SW_PAD_CTL_GRP_B1DS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRHYS: SW_PAD_CTL_GRP_DDRHYS {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRPKE: SW_PAD_CTL_GRP_DDRPKE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDRMODE: SW_PAD_CTL_GRP_DDRMODE {
                    _not_send_or_sync: PhantomData,
                },
                SW_PAD_CTL_GRP_DDR_TYPE: SW_PAD_CTL_GRP_DDR_TYPE {
                    _not_send_or_sync: PhantomData,
                },
                USB_OTG1_ID_SELECT_INPUT: USB_OTG1_ID_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USB_OTG2_ID_SELECT_INPUT: USB_OTG2_ID_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CCM_PMIC_READY_SELECT_INPUT: CCM_PMIC_READY_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA02_SELECT_INPUT: CSI_DATA02_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA03_SELECT_INPUT: CSI_DATA03_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA05_SELECT_INPUT: CSI_DATA05_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA00_SELECT_INPUT: CSI_DATA00_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA01_SELECT_INPUT: CSI_DATA01_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA04_SELECT_INPUT: CSI_DATA04_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA06_SELECT_INPUT: CSI_DATA06_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA07_SELECT_INPUT: CSI_DATA07_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA08_SELECT_INPUT: CSI_DATA08_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA09_SELECT_INPUT: CSI_DATA09_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA10_SELECT_INPUT: CSI_DATA10_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA11_SELECT_INPUT: CSI_DATA11_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA12_SELECT_INPUT: CSI_DATA12_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA13_SELECT_INPUT: CSI_DATA13_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA14_SELECT_INPUT: CSI_DATA14_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA15_SELECT_INPUT: CSI_DATA15_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA16_SELECT_INPUT: CSI_DATA16_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA17_SELECT_INPUT: CSI_DATA17_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA18_SELECT_INPUT: CSI_DATA18_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA19_SELECT_INPUT: CSI_DATA19_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA20_SELECT_INPUT: CSI_DATA20_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA21_SELECT_INPUT: CSI_DATA21_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA22_SELECT_INPUT: CSI_DATA22_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_DATA23_SELECT_INPUT: CSI_DATA23_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_HSYNC_SELECT_INPUT: CSI_HSYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_PIXCLK_SELECT_INPUT: CSI_PIXCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_VSYNC_SELECT_INPUT: CSI_VSYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                CSI_FIELD_SELECT_INPUT: CSI_FIELD_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI1_SCLK_SELECT_INPUT: ECSPI1_SCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI1_MISO_SELECT_INPUT: ECSPI1_MISO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI1_MOSI_SELECT_INPUT: ECSPI1_MOSI_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI1_SS0_B_SELECT_INPUT: ECSPI1_SS0_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI2_SCLK_SELECT_INPUT: ECSPI2_SCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI2_MISO_SELECT_INPUT: ECSPI2_MISO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI2_MOSI_SELECT_INPUT: ECSPI2_MOSI_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI2_SS0_B_SELECT_INPUT: ECSPI2_SS0_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI3_SCLK_SELECT_INPUT: ECSPI3_SCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI3_MISO_SELECT_INPUT: ECSPI3_MISO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI3_MOSI_SELECT_INPUT: ECSPI3_MOSI_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI3_SS0_B_SELECT_INPUT: ECSPI3_SS0_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI4_SCLK_SELECT_INPUT: ECSPI4_SCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI4_MISO_SELECT_INPUT: ECSPI4_MISO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI4_MOSI_SELECT_INPUT: ECSPI4_MOSI_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ECSPI4_SS0_B_SELECT_INPUT: ECSPI4_SS0_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ENET1_REF_CLK1_SELECT_INPUT: ENET1_REF_CLK1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ENET1_MAC0_MDIO_SELECT_INPUT: ENET1_MAC0_MDIO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ENET2_REF_CLK2_SELECT_INPUT: ENET2_REF_CLK2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                ENET2_MAC0_MDIO_SELECT_INPUT: ENET2_MAC0_MDIO_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                FLEXCAN1_RX_SELECT_INPUT: FLEXCAN1_RX_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                FLEXCAN2_RX_SELECT_INPUT: FLEXCAN2_RX_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT1_CAPTURE1_SELECT_INPUT: GPT1_CAPTURE1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT1_CAPTURE2_SELECT_INPUT: GPT1_CAPTURE2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT1_CLK_SELECT_INPUT: GPT1_CLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT2_CAPTURE1_SELECT_INPUT: GPT2_CAPTURE1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT2_CAPTURE2_SELECT_INPUT: GPT2_CAPTURE2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                GPT2_CLK_SELECT_INPUT: GPT2_CLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C1_SCL_SELECT_INPUT: I2C1_SCL_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C1_SDA_SELECT_INPUT: I2C1_SDA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C2_SCL_SELECT_INPUT: I2C2_SCL_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C2_SDA_SELECT_INPUT: I2C2_SDA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C3_SCL_SELECT_INPUT: I2C3_SCL_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C3_SDA_SELECT_INPUT: I2C3_SDA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C4_SCL_SELECT_INPUT: I2C4_SCL_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                I2C4_SDA_SELECT_INPUT: I2C4_SDA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_COL0_SELECT_INPUT: KPP_COL0_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_COL1_SELECT_INPUT: KPP_COL1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_COL2_SELECT_INPUT: KPP_COL2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_ROW0_SELECT_INPUT: KPP_ROW0_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_ROW1_SELECT_INPUT: KPP_ROW1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                KPP_ROW2_SELECT_INPUT: KPP_ROW2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                LCD_BUSY_SELECT_INPUT: LCD_BUSY_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI1_MCLK_SELECT_INPUT: SAI1_MCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI1_RX_DATA_SELECT_INPUT: SAI1_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI1_TX_BCLK_SELECT_INPUT: SAI1_TX_BCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI1_TX_SYNC_SELECT_INPUT: SAI1_TX_SYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI2_MCLK_SELECT_INPUT: SAI2_MCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI2_RX_DATA_SELECT_INPUT: SAI2_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI2_TX_BCLK_SELECT_INPUT: SAI2_TX_BCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI2_TX_SYNC_SELECT_INPUT: SAI2_TX_SYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI3_MCLK_SELECT_INPUT: SAI3_MCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI3_RX_DATA_SELECT_INPUT: SAI3_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI3_TX_BCLK_SELECT_INPUT: SAI3_TX_BCLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SAI3_TX_SYNC_SELECT_INPUT: SAI3_TX_SYNC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SDMA_EVENTS0_SELECT_INPUT: SDMA_EVENTS0_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SDMA_EVENTS1_SELECT_INPUT: SDMA_EVENTS1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SPDIF_IN_SELECT_INPUT: SPDIF_IN_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                SPDIF_EXT_CLK_SELECT_INPUT: SPDIF_EXT_CLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART1_RTS_B_SELECT_INPUT: UART1_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART1_RX_DATA_SELECT_INPUT: UART1_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART2_RTS_B_SELECT_INPUT: UART2_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART2_RX_DATA_SELECT_INPUT: UART2_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART3_RTS_B_SELECT_INPUT: UART3_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART3_RX_DATA_SELECT_INPUT: UART3_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART4_RTS_B_SELECT_INPUT: UART4_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART4_RX_DATA_SELECT_INPUT: UART4_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART5_RTS_B_SELECT_INPUT: UART5_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART5_RX_DATA_SELECT_INPUT: UART5_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART6_RTS_B_SELECT_INPUT: UART6_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART6_RX_DATA_SELECT_INPUT: UART6_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART7_RTS_B_SELECT_INPUT: UART7_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART7_RX_DATA_SELECT_INPUT: UART7_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART8_RTS_B_SELECT_INPUT: UART8_RTS_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                UART8_RX_DATA_SELECT_INPUT: UART8_RX_DATA_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USB_OTG2_OC_SELECT_INPUT: USB_OTG2_OC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USB_OTG_OC_SELECT_INPUT: USB_OTG_OC_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC1_CD_B_SELECT_INPUT: USDHC1_CD_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC1_WP_SELECT_INPUT: USDHC1_WP_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_CLK_SELECT_INPUT: USDHC2_CLK_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_CD_B_SELECT_INPUT: USDHC2_CD_B_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_CMD_SELECT_INPUT: USDHC2_CMD_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA0_SELECT_INPUT: USDHC2_DATA0_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA1_SELECT_INPUT: USDHC2_DATA1_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA2_SELECT_INPUT: USDHC2_DATA2_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA3_SELECT_INPUT: USDHC2_DATA3_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA4_SELECT_INPUT: USDHC2_DATA4_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA5_SELECT_INPUT: USDHC2_DATA5_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA6_SELECT_INPUT: USDHC2_DATA6_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_DATA7_SELECT_INPUT: USDHC2_DATA7_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
                USDHC2_WP_SELECT_INPUT: USDHC2_WP_SELECT_INPUT {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "rng")]
pub use rng::RNG;
#[allow(non_snake_case)]
#[cfg(feature = "rng")]
#[doc = "RNG"]
pub mod rng {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x0228_4000;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "RNGB version ID register"]
        pub VER: VER,
        #[doc = "RNGB command register"]
        pub CMD: CMD,
        #[doc = "RNGB control register"]
        pub CR: CR,
        #[doc = "RNGB status register"]
        pub SR: SR,
        #[doc = "RNGB error status register"]
        pub ESR: ESR,
        #[doc = "RNGB Output FIFO"]
        pub OUT: OUT,
    }
    unsafe impl Send for Registers {}
    #[doc = "RNGB version ID register"]
    #[allow(non_camel_case_types)]
    pub struct VER {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl VER {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1000_0280;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "RNGB command register"]
    #[allow(non_camel_case_types)]
    pub struct CMD {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CMD {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "RNGB control register"]
    #[allow(non_camel_case_types)]
    pub struct CR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CR {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "RNGB status register"]
    #[allow(non_camel_case_types)]
    pub struct SR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SR {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_500d;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "RNGB error status register"]
    #[allow(non_camel_case_types)]
    pub struct ESR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ESR {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "RNGB Output FIFO"]
    #[allow(non_camel_case_types)]
    pub struct OUT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl OUT {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                VER: VER {
                    _not_send_or_sync: PhantomData,
                },
                CMD: CMD {
                    _not_send_or_sync: PhantomData,
                },
                CR: CR {
                    _not_send_or_sync: PhantomData,
                },
                SR: SR {
                    _not_send_or_sync: PhantomData,
                },
                ESR: ESR {
                    _not_send_or_sync: PhantomData,
                },
                OUT: OUT {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "RNG"]
    pub type RNG = Registers;
    impl RNG {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                VER: VER {
                    _not_send_or_sync: PhantomData,
                },
                CMD: CMD {
                    _not_send_or_sync: PhantomData,
                },
                CR: CR {
                    _not_send_or_sync: PhantomData,
                },
                SR: SR {
                    _not_send_or_sync: PhantomData,
                },
                ESR: ESR {
                    _not_send_or_sync: PhantomData,
                },
                OUT: OUT {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "snvs_lp")]
pub use snvs_lp::SNVS_LP;
#[allow(non_snake_case)]
#[cfg(feature = "snvs_lp")]
#[doc = "SNVS_LP"]
pub mod snvs_lp {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x020c_c034;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "SNVS_LP Lock Register"]
        pub LR: LR,
        #[doc = "SNVS_LP Control Register"]
        pub CR: CR,
        #[doc = "SNVS_LP Status Register"]
        pub SR: SR,
        #[doc = "SNVS_LP Secure Monotonic Counter MSB Register"]
        pub SMCMR: SMCMR,
        #[doc = "SNVS_LP Secure Monotonic Counter LSB Register"]
        pub SMCLR: SMCLR,
        #[doc = "SNVS_LP General-Purpose Register"]
        pub GPR: GPR,
    }
    unsafe impl Send for Registers {}
    #[doc = "SNVS_LP Lock Register"]
    #[allow(non_camel_case_types)]
    pub struct LR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl LR {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_LP Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CR {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0020;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_LP Status Register"]
    #[allow(non_camel_case_types)]
    pub struct SR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SR {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0008;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_LP Secure Monotonic Counter MSB Register"]
    #[allow(non_camel_case_types)]
    pub struct SMCMR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SMCMR {
        const OFFSET: usize = 0x28;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_LP Secure Monotonic Counter LSB Register"]
    #[allow(non_camel_case_types)]
    pub struct SMCLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SMCLR {
        const OFFSET: usize = 0x2c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_LP General-Purpose Register"]
    #[allow(non_camel_case_types)]
    pub struct GPR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl GPR {
        const OFFSET: usize = 0x34;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                LR: LR {
                    _not_send_or_sync: PhantomData,
                },
                CR: CR {
                    _not_send_or_sync: PhantomData,
                },
                SR: SR {
                    _not_send_or_sync: PhantomData,
                },
                SMCMR: SMCMR {
                    _not_send_or_sync: PhantomData,
                },
                SMCLR: SMCLR {
                    _not_send_or_sync: PhantomData,
                },
                GPR: GPR {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SNVS_LP"]
    pub type SNVS_LP = Registers;
    impl SNVS_LP {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                LR: LR {
                    _not_send_or_sync: PhantomData,
                },
                CR: CR {
                    _not_send_or_sync: PhantomData,
                },
                SR: SR {
                    _not_send_or_sync: PhantomData,
                },
                SMCMR: SMCMR {
                    _not_send_or_sync: PhantomData,
                },
                SMCLR: SMCLR {
                    _not_send_or_sync: PhantomData,
                },
                GPR: GPR {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "snvs_hp")]
pub use snvs_hp::SNVS_HP;
#[allow(non_snake_case)]
#[cfg(feature = "snvs_hp")]
#[doc = "SNVS_HP"]
pub mod snvs_hp {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x020c_c000;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "SNVS_HP Lock register"]
        pub LR: LR,
        #[doc = "SNVS_HP Command register"]
        pub COMR: COMR,
        #[doc = "SNVS_HP Control register"]
        pub CR: CR,
        #[doc = "SNVS_HP Status register"]
        pub SR: SR,
        #[doc = "SNVS_HP Real-Time Counter MSB Register"]
        pub RTCMR: RTCMR,
        #[doc = "SNVS_HP Real-Time Counter LSB Register"]
        pub RTCLR: RTCLR,
        #[doc = "SNVS_HP Time Alarm MSB Register"]
        pub TAMR: TAMR,
        #[doc = "SNVS_HP Time Alarm LSB Register"]
        pub TALR: TALR,
        #[doc = "SNVS_HP Version ID Register 1"]
        pub VIDR1: VIDR1,
        #[doc = "SNVS_HP Version ID Register 2"]
        pub VIDR2: VIDR2,
    }
    unsafe impl Send for Registers {}
    #[doc = "SNVS_HP Lock register"]
    #[allow(non_camel_case_types)]
    pub struct LR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl LR {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Command register"]
    #[allow(non_camel_case_types)]
    pub struct COMR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl COMR {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Control register"]
    #[allow(non_camel_case_types)]
    pub struct CR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CR {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Status register"]
    #[allow(non_camel_case_types)]
    pub struct SR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SR {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x8000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Real-Time Counter MSB Register"]
    #[allow(non_camel_case_types)]
    pub struct RTCMR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl RTCMR {
        const OFFSET: usize = 0x24;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Real-Time Counter LSB Register"]
    #[allow(non_camel_case_types)]
    pub struct RTCLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl RTCLR {
        const OFFSET: usize = 0x28;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Time Alarm MSB Register"]
    #[allow(non_camel_case_types)]
    pub struct TAMR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl TAMR {
        const OFFSET: usize = 0x2c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Time Alarm LSB Register"]
    #[allow(non_camel_case_types)]
    pub struct TALR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl TALR {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Version ID Register 1"]
    #[allow(non_camel_case_types)]
    pub struct VIDR1 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl VIDR1 {
        const OFFSET: usize = 0x0bf8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x003e_0300;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "SNVS_HP Version ID Register 2"]
    #[allow(non_camel_case_types)]
    pub struct VIDR2 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl VIDR2 {
        const OFFSET: usize = 0x0bfc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0300_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                LR: LR {
                    _not_send_or_sync: PhantomData,
                },
                COMR: COMR {
                    _not_send_or_sync: PhantomData,
                },
                CR: CR {
                    _not_send_or_sync: PhantomData,
                },
                SR: SR {
                    _not_send_or_sync: PhantomData,
                },
                RTCMR: RTCMR {
                    _not_send_or_sync: PhantomData,
                },
                RTCLR: RTCLR {
                    _not_send_or_sync: PhantomData,
                },
                TAMR: TAMR {
                    _not_send_or_sync: PhantomData,
                },
                TALR: TALR {
                    _not_send_or_sync: PhantomData,
                },
                VIDR1: VIDR1 {
                    _not_send_or_sync: PhantomData,
                },
                VIDR2: VIDR2 {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SNVS_HP"]
    pub type SNVS_HP = Registers;
    impl SNVS_HP {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                LR: LR {
                    _not_send_or_sync: PhantomData,
                },
                COMR: COMR {
                    _not_send_or_sync: PhantomData,
                },
                CR: CR {
                    _not_send_or_sync: PhantomData,
                },
                SR: SR {
                    _not_send_or_sync: PhantomData,
                },
                RTCMR: RTCMR {
                    _not_send_or_sync: PhantomData,
                },
                RTCLR: RTCLR {
                    _not_send_or_sync: PhantomData,
                },
                TAMR: TAMR {
                    _not_send_or_sync: PhantomData,
                },
                TALR: TALR {
                    _not_send_or_sync: PhantomData,
                },
                VIDR1: VIDR1 {
                    _not_send_or_sync: PhantomData,
                },
                VIDR2: VIDR2 {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "uart")]
pub use uart::UART1;
#[cfg(feature = "uart")]
pub use uart::UART2;
#[cfg(feature = "uart")]
pub use uart::UART3;
#[cfg(feature = "uart")]
pub use uart::UART4;
#[cfg(feature = "uart")]
pub use uart::UART5;
#[cfg(feature = "uart")]
pub use uart::UART6;
#[cfg(feature = "uart")]
pub use uart::UART7;
#[cfg(feature = "uart")]
pub use uart::UART8;
#[allow(non_snake_case)]
#[cfg(feature = "uart")]
#[doc = "UART"]
pub mod uart {
    use crate::Peripheral;
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_sync: PhantomData<*mut ()>,
        #[doc = "UART Receiver Register"]
        pub URXD: URXD<P>,
        #[doc = "UART Transmitter Register"]
        pub UTXD: UTXD<P>,
        #[doc = "UART Control Register 1"]
        pub UCR1: UCR1<P>,
        #[doc = "UART Control Register 2"]
        pub UCR2: UCR2<P>,
        #[doc = "UART Control Register 3"]
        pub UCR3: UCR3<P>,
        #[doc = "UART Control Register 4"]
        pub UCR4: UCR4<P>,
        #[doc = "UART FIFO Control Register"]
        pub UFCR: UFCR<P>,
        #[doc = "UART Status Register 1"]
        pub USR1: USR1<P>,
        #[doc = "UART Status Register 2"]
        pub USR2: USR2<P>,
        #[doc = "UART Escape Character Register"]
        pub UESC: UESC<P>,
        #[doc = "UART Escape Timer Register"]
        pub UTIM: UTIM<P>,
        #[doc = "UART BRM Incremental Register"]
        pub UBIR: UBIR<P>,
        #[doc = "UART BRM Modulator Register"]
        pub UBMR: UBMR<P>,
        #[doc = "UART Baud Rate Count Register"]
        pub UBRC: UBRC<P>,
        #[doc = "UART One Millisecond Register"]
        pub ONEMS: ONEMS<P>,
        #[doc = "UART Test Register"]
        pub UTS: UTS<P>,
        #[doc = "UART RS-485 Mode Control Register"]
        pub UMCR: UMCR<P>,
    }
    unsafe impl<P> Send for Registers<P> where P: Peripheral {}
    #[doc = "UART Receiver Register"]
    #[allow(non_camel_case_types)]
    pub struct URXD<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> URXD<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Transmitter Register"]
    #[allow(non_camel_case_types)]
    pub struct UTXD<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UTXD<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x40;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Control Register 1"]
    #[allow(non_camel_case_types)]
    pub struct UCR1<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UCR1<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x80;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Control Register 2"]
    #[allow(non_camel_case_types)]
    pub struct UCR2<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UCR2<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x84;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Control Register 3"]
    #[allow(non_camel_case_types)]
    pub struct UCR3<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UCR3<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x88;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0700;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Control Register 4"]
    #[allow(non_camel_case_types)]
    pub struct UCR4<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UCR4<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x8c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART FIFO Control Register"]
    #[allow(non_camel_case_types)]
    pub struct UFCR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UFCR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x90;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0801;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Status Register 1"]
    #[allow(non_camel_case_types)]
    pub struct USR1<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> USR1<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x94;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_2040;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Status Register 2"]
    #[allow(non_camel_case_types)]
    pub struct USR2<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> USR2<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x98;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_4028;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Escape Character Register"]
    #[allow(non_camel_case_types)]
    pub struct UESC<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UESC<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x9c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_002b;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Escape Timer Register"]
    #[allow(non_camel_case_types)]
    pub struct UTIM<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UTIM<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xa0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART BRM Incremental Register"]
    #[allow(non_camel_case_types)]
    pub struct UBIR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UBIR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xa4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART BRM Modulator Register"]
    #[allow(non_camel_case_types)]
    pub struct UBMR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UBMR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xa8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Baud Rate Count Register"]
    #[allow(non_camel_case_types)]
    pub struct UBRC<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UBRC<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xac;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART One Millisecond Register"]
    #[allow(non_camel_case_types)]
    pub struct ONEMS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ONEMS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xb0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART Test Register"]
    #[allow(non_camel_case_types)]
    pub struct UTS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UTS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xb4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0060;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UART RS-485 Mode Control Register"]
    #[allow(non_camel_case_types)]
    pub struct UMCR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> UMCR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xb8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    impl<P> Registers<P>
    where
        P: Peripheral,
    {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _p: PhantomData,
                _not_sync: PhantomData,
                URXD: URXD {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UTXD: UTXD {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UCR1: UCR1 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UCR2: UCR2 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UCR3: UCR3 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UCR4: UCR4 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UFCR: UFCR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                USR1: USR1 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                USR2: USR2 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UESC: UESC {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UTIM: UTIM {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UBIR: UBIR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UBMR: UBMR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UBRC: UBRC {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ONEMS: ONEMS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UTS: UTS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                UMCR: UMCR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[doc = "UART1"]
    pub struct _1;
    impl Peripheral for _1 {
        const BASE_ADDRESS: usize = 0x0202_0000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "UART1"]
    pub type UART1 = Registers<_1>;
    impl UART1 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "UART2"]
    pub struct _2;
    impl Peripheral for _2 {
        const BASE_ADDRESS: usize = 0x021e_8000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "UART2"]
    pub type UART2 = Registers<_2>;
    impl UART2 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "UART3"]
    pub struct _3;
    impl Peripheral for _3 {
        const BASE_ADDRESS: usize = 0x021e_c000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "UART3"]
    pub type UART3 = Registers<_3>;
    impl UART3 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "UART4"]
    pub struct _4;
    impl Peripheral for _4 {
        const BASE_ADDRESS: usize = 0x021f_0000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "UART4"]
    pub type UART4 = Registers<_4>;
    impl UART4 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "UART5"]
    pub struct _5;
    impl Peripheral for _5 {
        const BASE_ADDRESS: usize = 0x021f_4000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "UART5"]
    pub type UART5 = Registers<_5>;
    impl UART5 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "UART6"]
    pub struct _6;
    impl Peripheral for _6 {
        const BASE_ADDRESS: usize = 0x021f_c000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "UART6"]
    pub type UART6 = Registers<_6>;
    impl UART6 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "UART7"]
    pub struct _7;
    impl Peripheral for _7 {
        const BASE_ADDRESS: usize = 0x0201_8000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "UART7"]
    pub type UART7 = Registers<_7>;
    impl UART7 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "UART8"]
    pub struct _8;
    impl Peripheral for _8 {
        const BASE_ADDRESS: usize = 0x0202_4000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "UART8"]
    pub type UART8 = Registers<_8>;
    impl UART8 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
}
#[cfg(feature = "usb_analog")]
pub use usb_analog::USB_ANALOG;
#[allow(non_snake_case)]
#[cfg(feature = "usb_analog")]
#[doc = "USB_ANALOG"]
pub mod usb_analog {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x020c_81a0;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "USB VBUS Detect Register"]
        pub USB1_VBUS_DETECT: USB1_VBUS_DETECT,
        #[doc = "USB VBUS Detect Register"]
        pub USB1_VBUS_DETECT_SET: USB1_VBUS_DETECT_SET,
        #[doc = "USB VBUS Detect Register"]
        pub USB1_VBUS_DETECT_CLR: USB1_VBUS_DETECT_CLR,
        #[doc = "USB VBUS Detect Register"]
        pub USB1_VBUS_DETECT_TOG: USB1_VBUS_DETECT_TOG,
        #[doc = "USB Charger Detect Register"]
        pub USB1_CHRG_DETECT: USB1_CHRG_DETECT,
        #[doc = "USB Charger Detect Register"]
        pub USB1_CHRG_DETECT_SET: USB1_CHRG_DETECT_SET,
        #[doc = "USB Charger Detect Register"]
        pub USB1_CHRG_DETECT_CLR: USB1_CHRG_DETECT_CLR,
        #[doc = "USB Charger Detect Register"]
        pub USB1_CHRG_DETECT_TOG: USB1_CHRG_DETECT_TOG,
        #[doc = "USB VBUS Detect Status Register"]
        pub USB1_VBUS_DETECT_STAT: USB1_VBUS_DETECT_STAT,
        #[doc = "USB Charger Detect Status Register"]
        pub USB1_CHRG_DETECT_STAT: USB1_CHRG_DETECT_STAT,
        #[doc = "USB Misc Register"]
        pub USB1_MISC: USB1_MISC,
        #[doc = "USB Misc Register"]
        pub USB1_MISC_SET: USB1_MISC_SET,
        #[doc = "USB Misc Register"]
        pub USB1_MISC_CLR: USB1_MISC_CLR,
        #[doc = "USB Misc Register"]
        pub USB1_MISC_TOG: USB1_MISC_TOG,
        #[doc = "USB VBUS Detect Register"]
        pub USB2_VBUS_DETECT: USB2_VBUS_DETECT,
        #[doc = "USB VBUS Detect Register"]
        pub USB2_VBUS_DETECT_SET: USB2_VBUS_DETECT_SET,
        #[doc = "USB VBUS Detect Register"]
        pub USB2_VBUS_DETECT_CLR: USB2_VBUS_DETECT_CLR,
        #[doc = "USB VBUS Detect Register"]
        pub USB2_VBUS_DETECT_TOG: USB2_VBUS_DETECT_TOG,
        #[doc = "USB Charger Detect Register"]
        pub USB2_CHRG_DETECT: USB2_CHRG_DETECT,
        #[doc = "USB Charger Detect Register"]
        pub USB2_CHRG_DETECT_SET: USB2_CHRG_DETECT_SET,
        #[doc = "USB Charger Detect Register"]
        pub USB2_CHRG_DETECT_CLR: USB2_CHRG_DETECT_CLR,
        #[doc = "USB Charger Detect Register"]
        pub USB2_CHRG_DETECT_TOG: USB2_CHRG_DETECT_TOG,
        #[doc = "USB VBUS Detect Status Register"]
        pub USB2_VBUS_DETECT_STAT: USB2_VBUS_DETECT_STAT,
        #[doc = "USB Charger Detect Status Register"]
        pub USB2_CHRG_DETECT_STAT: USB2_CHRG_DETECT_STAT,
        #[doc = "USB Misc Register"]
        pub USB2_MISC: USB2_MISC,
        #[doc = "USB Misc Register"]
        pub USB2_MISC_SET: USB2_MISC_SET,
        #[doc = "USB Misc Register"]
        pub USB2_MISC_CLR: USB2_MISC_CLR,
        #[doc = "USB Misc Register"]
        pub USB2_MISC_TOG: USB2_MISC_TOG,
        #[doc = "Chip Silicon Version"]
        pub DIGPROG: DIGPROG,
    }
    unsafe impl Send for Registers {}
    #[doc = "USB VBUS Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_VBUS_DETECT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_VBUS_DETECT {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0010_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_VBUS_DETECT_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_VBUS_DETECT_SET {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0010_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_VBUS_DETECT_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_VBUS_DETECT_CLR {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0010_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_VBUS_DETECT_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_VBUS_DETECT_TOG {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0010_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_CHRG_DETECT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_CHRG_DETECT {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_CHRG_DETECT_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_CHRG_DETECT_SET {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_CHRG_DETECT_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_CHRG_DETECT_CLR {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_CHRG_DETECT_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_CHRG_DETECT_TOG {
        const OFFSET: usize = 0x1c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Status Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_VBUS_DETECT_STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_VBUS_DETECT_STAT {
        const OFFSET: usize = 0x20;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Status Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_CHRG_DETECT_STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_CHRG_DETECT_STAT {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Misc Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_MISC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_MISC {
        const OFFSET: usize = 0x50;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Misc Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_MISC_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_MISC_SET {
        const OFFSET: usize = 0x54;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Misc Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_MISC_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_MISC_CLR {
        const OFFSET: usize = 0x58;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Misc Register"]
    #[allow(non_camel_case_types)]
    pub struct USB1_MISC_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB1_MISC_TOG {
        const OFFSET: usize = 0x5c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_VBUS_DETECT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_VBUS_DETECT {
        const OFFSET: usize = 0x60;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0010_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_VBUS_DETECT_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_VBUS_DETECT_SET {
        const OFFSET: usize = 0x64;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0010_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_VBUS_DETECT_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_VBUS_DETECT_CLR {
        const OFFSET: usize = 0x68;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0010_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_VBUS_DETECT_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_VBUS_DETECT_TOG {
        const OFFSET: usize = 0x6c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0010_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_CHRG_DETECT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_CHRG_DETECT {
        const OFFSET: usize = 0x70;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_CHRG_DETECT_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_CHRG_DETECT_SET {
        const OFFSET: usize = 0x74;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_CHRG_DETECT_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_CHRG_DETECT_CLR {
        const OFFSET: usize = 0x78;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_CHRG_DETECT_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_CHRG_DETECT_TOG {
        const OFFSET: usize = 0x7c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB VBUS Detect Status Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_VBUS_DETECT_STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_VBUS_DETECT_STAT {
        const OFFSET: usize = 0x80;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Charger Detect Status Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_CHRG_DETECT_STAT {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_CHRG_DETECT_STAT {
        const OFFSET: usize = 0x90;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Misc Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_MISC {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_MISC {
        const OFFSET: usize = 0xb0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Misc Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_MISC_SET {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_MISC_SET {
        const OFFSET: usize = 0xb4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Misc Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_MISC_CLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_MISC_CLR {
        const OFFSET: usize = 0xb8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB Misc Register"]
    #[allow(non_camel_case_types)]
    pub struct USB2_MISC_TOG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl USB2_MISC_TOG {
        const OFFSET: usize = 0xbc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Chip Silicon Version"]
    #[allow(non_camel_case_types)]
    pub struct DIGPROG {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl DIGPROG {
        const OFFSET: usize = 0xc0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0064_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                USB1_VBUS_DETECT: USB1_VBUS_DETECT {
                    _not_send_or_sync: PhantomData,
                },
                USB1_VBUS_DETECT_SET: USB1_VBUS_DETECT_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB1_VBUS_DETECT_CLR: USB1_VBUS_DETECT_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB1_VBUS_DETECT_TOG: USB1_VBUS_DETECT_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT: USB1_CHRG_DETECT {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT_SET: USB1_CHRG_DETECT_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT_CLR: USB1_CHRG_DETECT_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT_TOG: USB1_CHRG_DETECT_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB1_VBUS_DETECT_STAT: USB1_VBUS_DETECT_STAT {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT_STAT: USB1_CHRG_DETECT_STAT {
                    _not_send_or_sync: PhantomData,
                },
                USB1_MISC: USB1_MISC {
                    _not_send_or_sync: PhantomData,
                },
                USB1_MISC_SET: USB1_MISC_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB1_MISC_CLR: USB1_MISC_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB1_MISC_TOG: USB1_MISC_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT: USB2_VBUS_DETECT {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT_SET: USB2_VBUS_DETECT_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT_CLR: USB2_VBUS_DETECT_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT_TOG: USB2_VBUS_DETECT_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT: USB2_CHRG_DETECT {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT_SET: USB2_CHRG_DETECT_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT_CLR: USB2_CHRG_DETECT_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT_TOG: USB2_CHRG_DETECT_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT_STAT: USB2_VBUS_DETECT_STAT {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT_STAT: USB2_CHRG_DETECT_STAT {
                    _not_send_or_sync: PhantomData,
                },
                USB2_MISC: USB2_MISC {
                    _not_send_or_sync: PhantomData,
                },
                USB2_MISC_SET: USB2_MISC_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB2_MISC_CLR: USB2_MISC_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB2_MISC_TOG: USB2_MISC_TOG {
                    _not_send_or_sync: PhantomData,
                },
                DIGPROG: DIGPROG {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "USB_ANALOG"]
    pub type USB_ANALOG = Registers;
    impl USB_ANALOG {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                USB1_VBUS_DETECT: USB1_VBUS_DETECT {
                    _not_send_or_sync: PhantomData,
                },
                USB1_VBUS_DETECT_SET: USB1_VBUS_DETECT_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB1_VBUS_DETECT_CLR: USB1_VBUS_DETECT_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB1_VBUS_DETECT_TOG: USB1_VBUS_DETECT_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT: USB1_CHRG_DETECT {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT_SET: USB1_CHRG_DETECT_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT_CLR: USB1_CHRG_DETECT_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT_TOG: USB1_CHRG_DETECT_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB1_VBUS_DETECT_STAT: USB1_VBUS_DETECT_STAT {
                    _not_send_or_sync: PhantomData,
                },
                USB1_CHRG_DETECT_STAT: USB1_CHRG_DETECT_STAT {
                    _not_send_or_sync: PhantomData,
                },
                USB1_MISC: USB1_MISC {
                    _not_send_or_sync: PhantomData,
                },
                USB1_MISC_SET: USB1_MISC_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB1_MISC_CLR: USB1_MISC_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB1_MISC_TOG: USB1_MISC_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT: USB2_VBUS_DETECT {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT_SET: USB2_VBUS_DETECT_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT_CLR: USB2_VBUS_DETECT_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT_TOG: USB2_VBUS_DETECT_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT: USB2_CHRG_DETECT {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT_SET: USB2_CHRG_DETECT_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT_CLR: USB2_CHRG_DETECT_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT_TOG: USB2_CHRG_DETECT_TOG {
                    _not_send_or_sync: PhantomData,
                },
                USB2_VBUS_DETECT_STAT: USB2_VBUS_DETECT_STAT {
                    _not_send_or_sync: PhantomData,
                },
                USB2_CHRG_DETECT_STAT: USB2_CHRG_DETECT_STAT {
                    _not_send_or_sync: PhantomData,
                },
                USB2_MISC: USB2_MISC {
                    _not_send_or_sync: PhantomData,
                },
                USB2_MISC_SET: USB2_MISC_SET {
                    _not_send_or_sync: PhantomData,
                },
                USB2_MISC_CLR: USB2_MISC_CLR {
                    _not_send_or_sync: PhantomData,
                },
                USB2_MISC_TOG: USB2_MISC_TOG {
                    _not_send_or_sync: PhantomData,
                },
                DIGPROG: DIGPROG {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "usbnc_usb")]
pub use usbnc_usb::USBNC_USB;
#[allow(non_snake_case)]
#[cfg(feature = "usbnc_usb")]
#[doc = "USBNC_USB"]
pub mod usbnc_usb {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x0218_4800;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "USB OTG1 Control Register"]
        pub OTG1_CTRL: OTG1_CTRL,
        #[doc = "USB OTG2 Control Register"]
        pub OTG2_CTRL: OTG2_CTRL,
        #[doc = "OTG1 UTMI PHY Control 0 Register"]
        pub OTG1_PHY_CTRL_0: OTG1_PHY_CTRL_0,
        #[doc = "OTG2 UTMI PHY Control 0 Register"]
        pub OTG2_PHY_CTRL_0: OTG2_PHY_CTRL_0,
    }
    unsafe impl Send for Registers {}
    #[doc = "USB OTG1 Control Register"]
    #[allow(non_camel_case_types)]
    pub struct OTG1_CTRL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl OTG1_CTRL {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x3000_1000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "USB OTG2 Control Register"]
    #[allow(non_camel_case_types)]
    pub struct OTG2_CTRL {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl OTG2_CTRL {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x3000_1000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "OTG1 UTMI PHY Control 0 Register"]
    #[allow(non_camel_case_types)]
    pub struct OTG1_PHY_CTRL_0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl OTG1_PHY_CTRL_0 {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x8000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "OTG2 UTMI PHY Control 0 Register"]
    #[allow(non_camel_case_types)]
    pub struct OTG2_PHY_CTRL_0 {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl OTG2_PHY_CTRL_0 {
        const OFFSET: usize = 0x1c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x8000_0098;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                OTG1_CTRL: OTG1_CTRL {
                    _not_send_or_sync: PhantomData,
                },
                OTG2_CTRL: OTG2_CTRL {
                    _not_send_or_sync: PhantomData,
                },
                OTG1_PHY_CTRL_0: OTG1_PHY_CTRL_0 {
                    _not_send_or_sync: PhantomData,
                },
                OTG2_PHY_CTRL_0: OTG2_PHY_CTRL_0 {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "USBNC_USB"]
    pub type USBNC_USB = Registers;
    impl USBNC_USB {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                OTG1_CTRL: OTG1_CTRL {
                    _not_send_or_sync: PhantomData,
                },
                OTG2_CTRL: OTG2_CTRL {
                    _not_send_or_sync: PhantomData,
                },
                OTG1_PHY_CTRL_0: OTG1_PHY_CTRL_0 {
                    _not_send_or_sync: PhantomData,
                },
                OTG2_PHY_CTRL_0: OTG2_PHY_CTRL_0 {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "usbphy")]
pub use usbphy::USBPHY1;
#[cfg(feature = "usbphy")]
pub use usbphy::USBPHY2;
#[allow(non_snake_case)]
#[cfg(feature = "usbphy")]
#[doc = "USBPHY"]
pub mod usbphy {
    use crate::Peripheral;
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_sync: PhantomData<*mut ()>,
        #[doc = "USB PHY Power-Down Register"]
        pub PWD: PWD<P>,
        #[doc = "USB PHY Power-Down Register"]
        pub PWD_SET: PWD_SET<P>,
        #[doc = "USB PHY Power-Down Register"]
        pub PWD_CLR: PWD_CLR<P>,
        #[doc = "USB PHY Power-Down Register"]
        pub PWD_TOG: PWD_TOG<P>,
        #[doc = "USB PHY Transmitter Control Register"]
        pub TX: TX<P>,
        #[doc = "USB PHY Transmitter Control Register"]
        pub TX_SET: TX_SET<P>,
        #[doc = "USB PHY Transmitter Control Register"]
        pub TX_CLR: TX_CLR<P>,
        #[doc = "USB PHY Transmitter Control Register"]
        pub TX_TOG: TX_TOG<P>,
        #[doc = "USB PHY Receiver Control Register"]
        pub RX: RX<P>,
        #[doc = "USB PHY Receiver Control Register"]
        pub RX_SET: RX_SET<P>,
        #[doc = "USB PHY Receiver Control Register"]
        pub RX_CLR: RX_CLR<P>,
        #[doc = "USB PHY Receiver Control Register"]
        pub RX_TOG: RX_TOG<P>,
        #[doc = "USB PHY General Control Register"]
        pub CTRL: CTRL<P>,
        #[doc = "USB PHY General Control Register"]
        pub CTRL_SET: CTRL_SET<P>,
        #[doc = "USB PHY General Control Register"]
        pub CTRL_CLR: CTRL_CLR<P>,
        #[doc = "USB PHY General Control Register"]
        pub CTRL_TOG: CTRL_TOG<P>,
        #[doc = "USB PHY Status Register"]
        pub STATUS: STATUS<P>,
        #[doc = "USB PHY Debug Register"]
        pub DEBUG: DEBUG<P>,
        #[doc = "USB PHY Debug Register"]
        pub DEBUG_SET: DEBUG_SET<P>,
        #[doc = "USB PHY Debug Register"]
        pub DEBUG_CLR: DEBUG_CLR<P>,
        #[doc = "USB PHY Debug Register"]
        pub DEBUG_TOG: DEBUG_TOG<P>,
        #[doc = "UTMI Debug Status Register 0"]
        pub DEBUG0_STATUS: DEBUG0_STATUS<P>,
        #[doc = "UTMI Debug Status Register 1"]
        pub DEBUG1: DEBUG1<P>,
        #[doc = "UTMI Debug Status Register 1"]
        pub DEBUG1_SET: DEBUG1_SET<P>,
        #[doc = "UTMI Debug Status Register 1"]
        pub DEBUG1_CLR: DEBUG1_CLR<P>,
        #[doc = "UTMI Debug Status Register 1"]
        pub DEBUG1_TOG: DEBUG1_TOG<P>,
        #[doc = "UTMI RTL Version"]
        pub VERSION: VERSION<P>,
    }
    unsafe impl<P> Send for Registers<P> where P: Peripheral {}
    #[doc = "USB PHY Power-Down Register"]
    #[allow(non_camel_case_types)]
    pub struct PWD<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PWD<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x001e_1c00;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Power-Down Register"]
    #[allow(non_camel_case_types)]
    pub struct PWD_SET<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PWD_SET<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x001e_1c00;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Power-Down Register"]
    #[allow(non_camel_case_types)]
    pub struct PWD_CLR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PWD_CLR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x001e_1c00;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Power-Down Register"]
    #[allow(non_camel_case_types)]
    pub struct PWD_TOG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PWD_TOG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x001e_1c00;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Transmitter Control Register"]
    #[allow(non_camel_case_types)]
    pub struct TX<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> TX<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1006_0607;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Transmitter Control Register"]
    #[allow(non_camel_case_types)]
    pub struct TX_SET<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> TX_SET<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1006_0607;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Transmitter Control Register"]
    #[allow(non_camel_case_types)]
    pub struct TX_CLR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> TX_CLR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1006_0607;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Transmitter Control Register"]
    #[allow(non_camel_case_types)]
    pub struct TX_TOG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> TX_TOG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x1c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1006_0607;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Receiver Control Register"]
    #[allow(non_camel_case_types)]
    pub struct RX<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> RX<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x20;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Receiver Control Register"]
    #[allow(non_camel_case_types)]
    pub struct RX_SET<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> RX_SET<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x24;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Receiver Control Register"]
    #[allow(non_camel_case_types)]
    pub struct RX_CLR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> RX_CLR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x28;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Receiver Control Register"]
    #[allow(non_camel_case_types)]
    pub struct RX_TOG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> RX_TOG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x2c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY General Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CTRL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CTRL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xc020_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY General Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CTRL_SET<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CTRL_SET<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x34;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xc020_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY General Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CTRL_CLR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CTRL_CLR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x38;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xc020_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY General Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CTRL_TOG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CTRL_TOG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x3c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xc020_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Status Register"]
    #[allow(non_camel_case_types)]
    pub struct STATUS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> STATUS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x40;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Debug Register"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x50;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x7f18_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Debug Register"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG_SET<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG_SET<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x54;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x7f18_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Debug Register"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG_CLR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG_CLR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x58;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x7f18_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB PHY Debug Register"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG_TOG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG_TOG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x5c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x7f18_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UTMI Debug Status Register 0"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG0_STATUS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG0_STATUS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x60;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UTMI Debug Status Register 1"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG1<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG1<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x70;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_1000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UTMI Debug Status Register 1"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG1_SET<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG1_SET<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x74;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_1000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UTMI Debug Status Register 1"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG1_CLR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG1_CLR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x78;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_1000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UTMI Debug Status Register 1"]
    #[allow(non_camel_case_types)]
    pub struct DEBUG1_TOG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEBUG1_TOG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x7c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_1000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "UTMI RTL Version"]
    #[allow(non_camel_case_types)]
    pub struct VERSION<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> VERSION<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x80;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0402_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    impl<P> Registers<P>
    where
        P: Peripheral,
    {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _p: PhantomData,
                _not_sync: PhantomData,
                PWD: PWD {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                PWD_SET: PWD_SET {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                PWD_CLR: PWD_CLR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                PWD_TOG: PWD_TOG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                TX: TX {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                TX_SET: TX_SET {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                TX_CLR: TX_CLR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                TX_TOG: TX_TOG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                RX: RX {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                RX_SET: RX_SET {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                RX_CLR: RX_CLR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                RX_TOG: RX_TOG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CTRL: CTRL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CTRL_SET: CTRL_SET {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CTRL_CLR: CTRL_CLR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CTRL_TOG: CTRL_TOG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                STATUS: STATUS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG: DEBUG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG_SET: DEBUG_SET {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG_CLR: DEBUG_CLR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG_TOG: DEBUG_TOG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG0_STATUS: DEBUG0_STATUS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG1: DEBUG1 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG1_SET: DEBUG1_SET {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG1_CLR: DEBUG1_CLR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEBUG1_TOG: DEBUG1_TOG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                VERSION: VERSION {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[doc = "USBPHY1"]
    pub struct _1;
    impl Peripheral for _1 {
        const BASE_ADDRESS: usize = 0x020c_9000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "USBPHY1"]
    pub type USBPHY1 = Registers<_1>;
    impl USBPHY1 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "USBPHY2"]
    pub struct _2;
    impl Peripheral for _2 {
        const BASE_ADDRESS: usize = 0x020c_a000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "USBPHY2"]
    pub type USBPHY2 = Registers<_2>;
    impl USBPHY2 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
}
#[cfg(feature = "usb_uog")]
pub use usb_uog::USB_UOG1;
#[cfg(feature = "usb_uog")]
pub use usb_uog::USB_UOG2;
#[allow(non_snake_case)]
#[cfg(feature = "usb_uog")]
#[doc = "USB_UOG"]
pub mod usb_uog {
    use crate::Peripheral;
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_sync: PhantomData<*mut ()>,
        #[doc = "Identification register"]
        pub ID: ID<P>,
        #[doc = "Hardware General"]
        pub HWGENERAL: HWGENERAL<P>,
        #[doc = "Host Hardware Parameters"]
        pub HWHOST: HWHOST<P>,
        #[doc = "Device Hardware Parameters"]
        pub HWDEVICE: HWDEVICE<P>,
        #[doc = "TX Buffer Hardware Parameters"]
        pub HWTXBUF: HWTXBUF<P>,
        #[doc = "RX Buffer Hardware Parameters"]
        pub HWRXBUF: HWRXBUF<P>,
        #[doc = "General Purpose Timer #0 Load"]
        pub GPTIMER0LD: GPTIMER0LD<P>,
        #[doc = "General Purpose Timer #0 Controller"]
        pub GPTIMER0CTRL: GPTIMER0CTRL<P>,
        #[doc = "General Purpose Timer #1 Load"]
        pub GPTIMER1LD: GPTIMER1LD<P>,
        #[doc = "General Purpose Timer #1 Controller"]
        pub GPTIMER1CTRL: GPTIMER1CTRL<P>,
        #[doc = "System Bus Config"]
        pub SBUSCFG: SBUSCFG<P>,
        #[doc = "Capability Registers Length"]
        pub CAPLENGTH: CAPLENGTH<P>,
        #[doc = "Host Controller Interface Version"]
        pub HCIVERSION: HCIVERSION<P>,
        #[doc = "Host Controller Structural Parameters"]
        pub HCSPARAMS: HCSPARAMS<P>,
        #[doc = "Host Controller Capability Parameters"]
        pub HCCPARAMS: HCCPARAMS<P>,
        #[doc = "Device Controller Interface Version"]
        pub DCIVERSION: DCIVERSION<P>,
        #[doc = "Device Controller Capability Parameters"]
        pub DCCPARAMS: DCCPARAMS<P>,
        #[doc = "USB Command Register"]
        pub USBCMD: USBCMD<P>,
        #[doc = "USB Status Register"]
        pub USBSTS: USBSTS<P>,
        #[doc = "Interrupt Enable Register"]
        pub USBINTR: USBINTR<P>,
        #[doc = "USB Frame Index"]
        pub FRINDEX: FRINDEX<P>,
        #[doc = "Frame List Base Address"]
        pub PERIODICLISTBASE: PERIODICLISTBASE<P>,
        #[doc = "Device Address"]
        pub DEVICEADDR: DEVICEADDR<P>,
        #[doc = "Next Asynch. Address"]
        pub ASYNCLISTADDR: ASYNCLISTADDR<P>,
        #[doc = "Endpoint List Address"]
        pub ENDPTLISTADDR: ENDPTLISTADDR<P>,
        #[doc = "Programmable Burst Size"]
        pub BURSTSIZE: BURSTSIZE<P>,
        #[doc = "TX FIFO Fill Tuning"]
        pub TXFILLTUNING: TXFILLTUNING<P>,
        #[doc = "Endpoint NAK"]
        pub ENDPTNAK: ENDPTNAK<P>,
        #[doc = "Endpoint NAK Enable"]
        pub ENDPTNAKEN: ENDPTNAKEN<P>,
        #[doc = "Configure Flag Register"]
        pub CONFIGFLAG: CONFIGFLAG<P>,
        #[doc = "Port Status & Control"]
        pub PORTSC1: PORTSC1<P>,
        #[doc = "On-The-Go Status & control"]
        pub OTGSC: OTGSC<P>,
        #[doc = "USB Device Mode"]
        pub USBMODE: USBMODE<P>,
        #[doc = "Endpoint Setup Status"]
        pub ENDPTSETUPSTAT: ENDPTSETUPSTAT<P>,
        #[doc = "Endpoint Prime"]
        pub ENDPTPRIME: ENDPTPRIME<P>,
        #[doc = "Endpoint Flush"]
        pub ENDPTFLUSH: ENDPTFLUSH<P>,
        #[doc = "Endpoint Status"]
        pub ENDPTSTAT: ENDPTSTAT<P>,
        #[doc = "Endpoint Complete"]
        pub ENDPTCOMPLETE: ENDPTCOMPLETE<P>,
        #[doc = "Endpoint Control0"]
        pub ENDPTCTRL0: ENDPTCTRL0<P>,
        #[doc = "Endpoint Control 1"]
        pub ENDPTCTRL1: ENDPTCTRL1<P>,
        #[doc = "Endpoint Control 2"]
        pub ENDPTCTRL2: ENDPTCTRL2<P>,
        #[doc = "Endpoint Control 3"]
        pub ENDPTCTRL3: ENDPTCTRL3<P>,
        #[doc = "Endpoint Control 4"]
        pub ENDPTCTRL4: ENDPTCTRL4<P>,
        #[doc = "Endpoint Control 5"]
        pub ENDPTCTRL5: ENDPTCTRL5<P>,
        #[doc = "Endpoint Control 6"]
        pub ENDPTCTRL6: ENDPTCTRL6<P>,
        #[doc = "Endpoint Control 7"]
        pub ENDPTCTRL7: ENDPTCTRL7<P>,
    }
    unsafe impl<P> Send for Registers<P> where P: Peripheral {}
    #[doc = "Identification register"]
    #[allow(non_camel_case_types)]
    pub struct ID<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ID<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0xe4a1_fa05;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Hardware General"]
    #[allow(non_camel_case_types)]
    pub struct HWGENERAL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HWGENERAL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0035;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Host Hardware Parameters"]
    #[allow(non_camel_case_types)]
    pub struct HWHOST<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HWHOST<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1002_0001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Device Hardware Parameters"]
    #[allow(non_camel_case_types)]
    pub struct HWDEVICE<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HWDEVICE<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0011;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "TX Buffer Hardware Parameters"]
    #[allow(non_camel_case_types)]
    pub struct HWTXBUF<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HWTXBUF<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x8008_0b08;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "RX Buffer Hardware Parameters"]
    #[allow(non_camel_case_types)]
    pub struct HWRXBUF<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HWRXBUF<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0808;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "General Purpose Timer #0 Load"]
    #[allow(non_camel_case_types)]
    pub struct GPTIMER0LD<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> GPTIMER0LD<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x80;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "General Purpose Timer #0 Controller"]
    #[allow(non_camel_case_types)]
    pub struct GPTIMER0CTRL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> GPTIMER0CTRL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x84;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "General Purpose Timer #1 Load"]
    #[allow(non_camel_case_types)]
    pub struct GPTIMER1LD<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> GPTIMER1LD<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x88;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "General Purpose Timer #1 Controller"]
    #[allow(non_camel_case_types)]
    pub struct GPTIMER1CTRL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> GPTIMER1CTRL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x8c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "System Bus Config"]
    #[allow(non_camel_case_types)]
    pub struct SBUSCFG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> SBUSCFG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x90;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0002;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Capability Registers Length"]
    #[allow(non_camel_case_types)]
    pub struct CAPLENGTH<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CAPLENGTH<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0100;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u8 = 0x0000_0040;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u8 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u8).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u8 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u8)
        }
    }
    #[doc = "Host Controller Interface Version"]
    #[allow(non_camel_case_types)]
    pub struct HCIVERSION<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HCIVERSION<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0102;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0100;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "Host Controller Structural Parameters"]
    #[allow(non_camel_case_types)]
    pub struct HCSPARAMS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HCSPARAMS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0104;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0001_0011;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Host Controller Capability Parameters"]
    #[allow(non_camel_case_types)]
    pub struct HCCPARAMS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HCCPARAMS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0108;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0006;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Device Controller Interface Version"]
    #[allow(non_camel_case_types)]
    pub struct DCIVERSION<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DCIVERSION<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0120;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "Device Controller Capability Parameters"]
    #[allow(non_camel_case_types)]
    pub struct DCCPARAMS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DCCPARAMS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0124;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0188;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB Command Register"]
    #[allow(non_camel_case_types)]
    pub struct USBCMD<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> USBCMD<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0140;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0008_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB Status Register"]
    #[allow(non_camel_case_types)]
    pub struct USBSTS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> USBSTS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0144;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Interrupt Enable Register"]
    #[allow(non_camel_case_types)]
    pub struct USBINTR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> USBINTR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0148;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB Frame Index"]
    #[allow(non_camel_case_types)]
    pub struct FRINDEX<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> FRINDEX<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x014c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Frame List Base Address"]
    #[allow(non_camel_case_types)]
    pub struct PERIODICLISTBASE<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PERIODICLISTBASE<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0154;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Device Address"]
    #[allow(non_camel_case_types)]
    pub struct DEVICEADDR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DEVICEADDR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0154;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Next Asynch. Address"]
    #[allow(non_camel_case_types)]
    pub struct ASYNCLISTADDR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ASYNCLISTADDR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0158;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint List Address"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTLISTADDR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTLISTADDR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0158;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Programmable Burst Size"]
    #[allow(non_camel_case_types)]
    pub struct BURSTSIZE<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> BURSTSIZE<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0160;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0808;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "TX FIFO Fill Tuning"]
    #[allow(non_camel_case_types)]
    pub struct TXFILLTUNING<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> TXFILLTUNING<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0164;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x000a_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint NAK"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTNAK<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTNAK<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0178;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint NAK Enable"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTNAKEN<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTNAKEN<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x017c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Configure Flag Register"]
    #[allow(non_camel_case_types)]
    pub struct CONFIGFLAG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CONFIGFLAG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0180;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Port Status & Control"]
    #[allow(non_camel_case_types)]
    pub struct PORTSC1<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PORTSC1<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0184;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x1000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "On-The-Go Status & control"]
    #[allow(non_camel_case_types)]
    pub struct OTGSC<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> OTGSC<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01a4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_1120;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "USB Device Mode"]
    #[allow(non_camel_case_types)]
    pub struct USBMODE<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> USBMODE<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01a8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_5000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Setup Status"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTSETUPSTAT<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTSETUPSTAT<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01ac;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Prime"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTPRIME<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTPRIME<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01b0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Flush"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTFLUSH<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTFLUSH<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01b4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Status"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTSTAT<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTSTAT<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01b8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Complete"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCOMPLETE<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCOMPLETE<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01bc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Control0"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCTRL0<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCTRL0<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01c0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0080_0080;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Control 1"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCTRL1<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCTRL1<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01c4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Control 2"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCTRL2<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCTRL2<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01c8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Control 3"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCTRL3<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCTRL3<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01cc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Control 4"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCTRL4<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCTRL4<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01d0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Control 5"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCTRL5<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCTRL5<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01d4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Control 6"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCTRL6<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCTRL6<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01d8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Endpoint Control 7"]
    #[allow(non_camel_case_types)]
    pub struct ENDPTCTRL7<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ENDPTCTRL7<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x01dc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    impl<P> Registers<P>
    where
        P: Peripheral,
    {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _p: PhantomData,
                _not_sync: PhantomData,
                ID: ID {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HWGENERAL: HWGENERAL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HWHOST: HWHOST {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HWDEVICE: HWDEVICE {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HWTXBUF: HWTXBUF {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HWRXBUF: HWRXBUF {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                GPTIMER0LD: GPTIMER0LD {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                GPTIMER0CTRL: GPTIMER0CTRL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                GPTIMER1LD: GPTIMER1LD {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                GPTIMER1CTRL: GPTIMER1CTRL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                SBUSCFG: SBUSCFG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CAPLENGTH: CAPLENGTH {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HCIVERSION: HCIVERSION {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HCSPARAMS: HCSPARAMS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HCCPARAMS: HCCPARAMS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DCIVERSION: DCIVERSION {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DCCPARAMS: DCCPARAMS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                USBCMD: USBCMD {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                USBSTS: USBSTS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                USBINTR: USBINTR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                FRINDEX: FRINDEX {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                PERIODICLISTBASE: PERIODICLISTBASE {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DEVICEADDR: DEVICEADDR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ASYNCLISTADDR: ASYNCLISTADDR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTLISTADDR: ENDPTLISTADDR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                BURSTSIZE: BURSTSIZE {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                TXFILLTUNING: TXFILLTUNING {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTNAK: ENDPTNAK {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTNAKEN: ENDPTNAKEN {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CONFIGFLAG: CONFIGFLAG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                PORTSC1: PORTSC1 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                OTGSC: OTGSC {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                USBMODE: USBMODE {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTSETUPSTAT: ENDPTSETUPSTAT {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTPRIME: ENDPTPRIME {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTFLUSH: ENDPTFLUSH {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTSTAT: ENDPTSTAT {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCOMPLETE: ENDPTCOMPLETE {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCTRL0: ENDPTCTRL0 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCTRL1: ENDPTCTRL1 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCTRL2: ENDPTCTRL2 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCTRL3: ENDPTCTRL3 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCTRL4: ENDPTCTRL4 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCTRL5: ENDPTCTRL5 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCTRL6: ENDPTCTRL6 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ENDPTCTRL7: ENDPTCTRL7 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[doc = "USB_UOG1"]
    pub struct _1;
    impl Peripheral for _1 {
        const BASE_ADDRESS: usize = 0x0218_4000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "USB_UOG1"]
    pub type USB_UOG1 = Registers<_1>;
    impl USB_UOG1 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "USB_UOG2"]
    pub struct _2;
    impl Peripheral for _2 {
        const BASE_ADDRESS: usize = 0x0218_4200;
    }
    #[allow(non_camel_case_types)]
    #[doc = "USB_UOG2"]
    pub type USB_UOG2 = Registers<_2>;
    impl USB_UOG2 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
}
#[cfg(feature = "usdhc")]
pub use usdhc::uSDHC1;
#[cfg(feature = "usdhc")]
pub use usdhc::uSDHC2;
#[allow(non_snake_case)]
#[cfg(feature = "usdhc")]
#[doc = "uSDHC"]
pub mod usdhc {
    use crate::Peripheral;
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_sync: PhantomData<*mut ()>,
        #[doc = "DMA System Address"]
        pub DS_ADDR: DS_ADDR<P>,
        #[doc = "Block Attributes"]
        pub BLK_ATT: BLK_ATT<P>,
        #[doc = "Command Argument"]
        pub CMD_ARG: CMD_ARG<P>,
        #[doc = "Command Transfer Type"]
        pub CMD_XFR_TYP: CMD_XFR_TYP<P>,
        #[doc = "Command Response0"]
        pub CMD_RSP0: CMD_RSP0<P>,
        #[doc = "Command Response1"]
        pub CMD_RSP1: CMD_RSP1<P>,
        #[doc = "Command Response2"]
        pub CMD_RSP2: CMD_RSP2<P>,
        #[doc = "Command Response3"]
        pub CMD_RSP3: CMD_RSP3<P>,
        #[doc = "Data Buffer Access Port"]
        pub DATA_BUFF_ACC_PORT: DATA_BUFF_ACC_PORT<P>,
        #[doc = "Present State"]
        pub PRES_STATE: PRES_STATE<P>,
        #[doc = "Protocol Control"]
        pub PROT_CTRL: PROT_CTRL<P>,
        #[doc = "System Control"]
        pub SYS_CTRL: SYS_CTRL<P>,
        #[doc = "Interrupt Status"]
        pub INT_STATUS: INT_STATUS<P>,
        #[doc = "Interrupt Status Enable"]
        pub INT_STATUS_EN: INT_STATUS_EN<P>,
        #[doc = "Interrupt Signal Enable"]
        pub INT_SIGNAL_EN: INT_SIGNAL_EN<P>,
        #[doc = "Auto CMD12 Error Status"]
        pub AUTOCMD12_ERR_STATUS: AUTOCMD12_ERR_STATUS<P>,
        #[doc = "Host Controller Capabilities"]
        pub HOST_CTRL_CAP: HOST_CTRL_CAP<P>,
        #[doc = "Watermark Level"]
        pub WTMK_LVL: WTMK_LVL<P>,
        #[doc = "Mixer Control"]
        pub MIX_CTRL: MIX_CTRL<P>,
        #[doc = "ADMA Error Status Register"]
        pub ADMA_ERR_STATUS: ADMA_ERR_STATUS<P>,
        #[doc = "ADMA System Address"]
        pub ADMA_SYS_ADDR: ADMA_SYS_ADDR<P>,
        #[doc = "DLL (Delay Line) Control"]
        pub DLL_CTRL: DLL_CTRL<P>,
        #[doc = "DLL Status"]
        pub DLL_STATUS: DLL_STATUS<P>,
        #[doc = "CLK Tuning Control and Status"]
        pub CLK_TUNE_CTRL_STATUS: CLK_TUNE_CTRL_STATUS<P>,
        #[doc = "Vendor Specific Register"]
        pub VEND_SPEC: VEND_SPEC<P>,
        #[doc = "MMC Boot Register"]
        pub MMC_BOOT: MMC_BOOT<P>,
        #[doc = "Vendor Specific 2 Register"]
        pub VEND_SPEC2: VEND_SPEC2<P>,
        #[doc = "Tuning Control Register"]
        pub TUNING_CTRL: TUNING_CTRL<P>,
    }
    unsafe impl<P> Send for Registers<P> where P: Peripheral {}
    #[doc = "DMA System Address"]
    #[allow(non_camel_case_types)]
    pub struct DS_ADDR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DS_ADDR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Block Attributes"]
    #[allow(non_camel_case_types)]
    pub struct BLK_ATT<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> BLK_ATT<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Command Argument"]
    #[allow(non_camel_case_types)]
    pub struct CMD_ARG<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CMD_ARG<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Command Transfer Type"]
    #[allow(non_camel_case_types)]
    pub struct CMD_XFR_TYP<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CMD_XFR_TYP<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Command Response0"]
    #[allow(non_camel_case_types)]
    pub struct CMD_RSP0<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CMD_RSP0<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x10;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Command Response1"]
    #[allow(non_camel_case_types)]
    pub struct CMD_RSP1<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CMD_RSP1<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Command Response2"]
    #[allow(non_camel_case_types)]
    pub struct CMD_RSP2<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CMD_RSP2<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x18;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Command Response3"]
    #[allow(non_camel_case_types)]
    pub struct CMD_RSP3<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CMD_RSP3<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x1c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Data Buffer Access Port"]
    #[allow(non_camel_case_types)]
    pub struct DATA_BUFF_ACC_PORT<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DATA_BUFF_ACC_PORT<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x20;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Present State"]
    #[allow(non_camel_case_types)]
    pub struct PRES_STATE<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PRES_STATE<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x24;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_8080;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Protocol Control"]
    #[allow(non_camel_case_types)]
    pub struct PROT_CTRL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> PROT_CTRL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x28;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0880_0020;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "System Control"]
    #[allow(non_camel_case_types)]
    pub struct SYS_CTRL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> SYS_CTRL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x2c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x8080_800f;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Interrupt Status"]
    #[allow(non_camel_case_types)]
    pub struct INT_STATUS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> INT_STATUS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x30;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn clear(&self, mask: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(mask) }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Interrupt Status Enable"]
    #[allow(non_camel_case_types)]
    pub struct INT_STATUS_EN<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> INT_STATUS_EN<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x34;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Interrupt Signal Enable"]
    #[allow(non_camel_case_types)]
    pub struct INT_SIGNAL_EN<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> INT_SIGNAL_EN<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x38;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Auto CMD12 Error Status"]
    #[allow(non_camel_case_types)]
    pub struct AUTOCMD12_ERR_STATUS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> AUTOCMD12_ERR_STATUS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x3c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Host Controller Capabilities"]
    #[allow(non_camel_case_types)]
    pub struct HOST_CTRL_CAP<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> HOST_CTRL_CAP<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x40;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x07f3_b407;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Watermark Level"]
    #[allow(non_camel_case_types)]
    pub struct WTMK_LVL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> WTMK_LVL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x44;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0810_0810;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Mixer Control"]
    #[allow(non_camel_case_types)]
    pub struct MIX_CTRL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> MIX_CTRL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x48;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x8000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "ADMA Error Status Register"]
    #[allow(non_camel_case_types)]
    pub struct ADMA_ERR_STATUS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ADMA_ERR_STATUS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x54;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "ADMA System Address"]
    #[allow(non_camel_case_types)]
    pub struct ADMA_SYS_ADDR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> ADMA_SYS_ADDR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x58;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "DLL (Delay Line) Control"]
    #[allow(non_camel_case_types)]
    pub struct DLL_CTRL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DLL_CTRL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x60;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0200;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "DLL Status"]
    #[allow(non_camel_case_types)]
    pub struct DLL_STATUS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> DLL_STATUS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x64;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "CLK Tuning Control and Status"]
    #[allow(non_camel_case_types)]
    pub struct CLK_TUNE_CTRL_STATUS<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> CLK_TUNE_CTRL_STATUS<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x68;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Vendor Specific Register"]
    #[allow(non_camel_case_types)]
    pub struct VEND_SPEC<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> VEND_SPEC<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xc0;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x2000_7809;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "MMC Boot Register"]
    #[allow(non_camel_case_types)]
    pub struct MMC_BOOT<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> MMC_BOOT<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xc4;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Vendor Specific 2 Register"]
    #[allow(non_camel_case_types)]
    pub struct VEND_SPEC2<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> VEND_SPEC2<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xc8;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0006;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    #[doc = "Tuning Control Register"]
    #[allow(non_camel_case_types)]
    pub struct TUNING_CTRL<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> TUNING_CTRL<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0xcc;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0021_2800;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u32 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u32)
        }
    }
    impl<P> Registers<P>
    where
        P: Peripheral,
    {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _p: PhantomData,
                _not_sync: PhantomData,
                DS_ADDR: DS_ADDR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                BLK_ATT: BLK_ATT {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CMD_ARG: CMD_ARG {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CMD_XFR_TYP: CMD_XFR_TYP {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CMD_RSP0: CMD_RSP0 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CMD_RSP1: CMD_RSP1 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CMD_RSP2: CMD_RSP2 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CMD_RSP3: CMD_RSP3 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DATA_BUFF_ACC_PORT: DATA_BUFF_ACC_PORT {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                PRES_STATE: PRES_STATE {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                PROT_CTRL: PROT_CTRL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                SYS_CTRL: SYS_CTRL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                INT_STATUS: INT_STATUS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                INT_STATUS_EN: INT_STATUS_EN {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                INT_SIGNAL_EN: INT_SIGNAL_EN {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                AUTOCMD12_ERR_STATUS: AUTOCMD12_ERR_STATUS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                HOST_CTRL_CAP: HOST_CTRL_CAP {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                WTMK_LVL: WTMK_LVL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                MIX_CTRL: MIX_CTRL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ADMA_ERR_STATUS: ADMA_ERR_STATUS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                ADMA_SYS_ADDR: ADMA_SYS_ADDR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DLL_CTRL: DLL_CTRL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                DLL_STATUS: DLL_STATUS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                CLK_TUNE_CTRL_STATUS: CLK_TUNE_CTRL_STATUS {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                VEND_SPEC: VEND_SPEC {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                MMC_BOOT: MMC_BOOT {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                VEND_SPEC2: VEND_SPEC2 {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                TUNING_CTRL: TUNING_CTRL {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[doc = "uSDHC1"]
    pub struct _1;
    impl Peripheral for _1 {
        const BASE_ADDRESS: usize = 0x0219_0000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "uSDHC1"]
    pub type uSDHC1 = Registers<_1>;
    impl uSDHC1 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "uSDHC2"]
    pub struct _2;
    impl Peripheral for _2 {
        const BASE_ADDRESS: usize = 0x0219_4000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "uSDHC2"]
    pub type uSDHC2 = Registers<_2>;
    impl uSDHC2 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
}
#[cfg(feature = "wdog")]
pub use wdog::WDOG1;
#[cfg(feature = "wdog")]
pub use wdog::WDOG2;
#[cfg(feature = "wdog")]
pub use wdog::WDOG3;
#[allow(non_snake_case)]
#[cfg(feature = "wdog")]
#[doc = "WDOG"]
pub mod wdog {
    use crate::Peripheral;
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_sync: PhantomData<*mut ()>,
        #[doc = "Watchdog Control Register"]
        pub WCR: WCR<P>,
        #[doc = "Watchdog Service Register"]
        pub WSR: WSR<P>,
        #[doc = "Watchdog Reset Status Register"]
        pub WRSR: WRSR<P>,
        #[doc = "Watchdog Interrupt Control Register"]
        pub WICR: WICR<P>,
        #[doc = "Watchdog Miscellaneous Control Register"]
        pub WMCR: WMCR<P>,
    }
    unsafe impl<P> Send for Registers<P> where P: Peripheral {}
    #[doc = "Watchdog Control Register"]
    #[allow(non_camel_case_types)]
    pub struct WCR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> WCR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0030;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "Watchdog Service Register"]
    #[allow(non_camel_case_types)]
    pub struct WSR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> WSR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x02;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "Watchdog Reset Status Register"]
    #[allow(non_camel_case_types)]
    pub struct WRSR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> WRSR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "Watchdog Interrupt Control Register"]
    #[allow(non_camel_case_types)]
    pub struct WICR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> WICR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x06;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0004;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    #[doc = "Watchdog Miscellaneous Control Register"]
    #[allow(non_camel_case_types)]
    pub struct WMCR<P>
    where
        P: Peripheral,
    {
        _p: PhantomData<P>,
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl<P> WMCR<P>
    where
        P: Peripheral,
    {
        const OFFSET: usize = 0x08;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u16 = 0x0000_0001;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u16 {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *const u16).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u16) {
            unsafe { ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u16) -> u16) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        pub fn address() -> *mut u16 {
            ((P::BASE_ADDRESS + Self::OFFSET) as *mut u16)
        }
    }
    impl<P> Registers<P>
    where
        P: Peripheral,
    {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _p: PhantomData,
                _not_sync: PhantomData,
                WCR: WCR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                WSR: WSR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                WRSR: WRSR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                WICR: WICR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
                WMCR: WMCR {
                    _p: PhantomData,
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[doc = "WDOG1"]
    pub struct _1;
    impl Peripheral for _1 {
        const BASE_ADDRESS: usize = 0x020b_c000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "WDOG1"]
    pub type WDOG1 = Registers<_1>;
    impl WDOG1 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "WDOG2"]
    pub struct _2;
    impl Peripheral for _2 {
        const BASE_ADDRESS: usize = 0x020c_0000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "WDOG2"]
    pub type WDOG2 = Registers<_2>;
    impl WDOG2 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
    #[doc = "WDOG3"]
    pub struct _3;
    impl Peripheral for _3 {
        const BASE_ADDRESS: usize = 0x021e_4000;
    }
    #[allow(non_camel_case_types)]
    #[doc = "WDOG3"]
    pub type WDOG3 = Registers<_3>;
    impl WDOG3 {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Registers::new() })
        }
    }
}
#[cfg(feature = "gicc")]
pub use gicc::GICC;
#[allow(non_snake_case)]
#[cfg(feature = "gicc")]
#[doc = "GICC"]
pub mod gicc {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x00a0_2000;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "CPU Interface Control Register"]
        pub CTLR: CTLR,
        #[doc = "Interrupt Priority Mask Register"]
        pub PMR: PMR,
        #[doc = "Interrupt Acknowledge Register"]
        pub IAR: IAR,
        #[doc = "End of Interrupt Register"]
        pub EOIR: EOIR,
        #[doc = "Running Priority Register"]
        pub RPR: RPR,
    }
    unsafe impl Send for Registers {}
    #[doc = "CPU Interface Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CTLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CTLR {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Interrupt Priority Mask Register"]
    #[allow(non_camel_case_types)]
    pub struct PMR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl PMR {
        const OFFSET: usize = 0x04;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub unsafe fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub unsafe fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub unsafe fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Interrupt Acknowledge Register"]
    #[allow(non_camel_case_types)]
    pub struct IAR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl IAR {
        const OFFSET: usize = 0x0c;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_03ff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "End of Interrupt Register"]
    #[allow(non_camel_case_types)]
    pub struct EOIR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl EOIR {
        const OFFSET: usize = 0x10;
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Running Priority Register"]
    #[allow(non_camel_case_types)]
    pub struct RPR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl RPR {
        const OFFSET: usize = 0x14;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_00ff;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                CTLR: CTLR {
                    _not_send_or_sync: PhantomData,
                },
                PMR: PMR {
                    _not_send_or_sync: PhantomData,
                },
                IAR: IAR {
                    _not_send_or_sync: PhantomData,
                },
                EOIR: EOIR {
                    _not_send_or_sync: PhantomData,
                },
                RPR: RPR {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "GICC"]
    pub type GICC = Registers;
    impl GICC {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                CTLR: CTLR {
                    _not_send_or_sync: PhantomData,
                },
                PMR: PMR {
                    _not_send_or_sync: PhantomData,
                },
                IAR: IAR {
                    _not_send_or_sync: PhantomData,
                },
                EOIR: EOIR {
                    _not_send_or_sync: PhantomData,
                },
                RPR: RPR {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
#[cfg(feature = "gicd")]
pub use gicd::GICD;
#[allow(non_snake_case)]
#[cfg(feature = "gicd")]
#[doc = "GICD"]
pub mod gicd {
    use core::{
        marker::PhantomData,
        sync::atomic::{AtomicBool, Ordering},
    };
    const BASE_ADDRESS: usize = 0x00a0_1000;
    #[doc = r" The registers that make up the peripheral"]
    #[allow(non_snake_case)]
    pub struct Registers {
        _not_sync: PhantomData<*mut ()>,
        #[doc = "Distributor Control Register"]
        pub CTLR: CTLR,
        #[doc = "Interrupt Set-Enable Registers (4 instances)"]
        pub ISENABLER: ISENABLER,
        #[doc = "Interrupt Priority Registers (128 instances)"]
        pub IPRIORITYR: IPRIORITYR,
        #[doc = "Software Generated Interrupt Register"]
        pub SGIR: SGIR,
    }
    unsafe impl Send for Registers {}
    #[doc = "Distributor Control Register"]
    #[allow(non_camel_case_types)]
    pub struct CTLR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl CTLR {
        const OFFSET: usize = 0x00;
        #[doc = r" Reset value"]
        pub const RESET_VALUE: u32 = 0x0000_0000;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self) -> u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *const u32).read_volatile() }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub fn rmw(&self, f: impl FnOnce(u32) -> u32) {
            self.write(f(self.read()))
        }
        #[doc = r" Writes the reset value"]
        #[allow(unused_unsafe)]
        pub fn reset(&self) {
            self.write(Self::RESET_VALUE)
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    #[doc = "Interrupt Set-Enable Registers (4 instances)"]
    #[allow(non_camel_case_types)]
    pub struct ISENABLER {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl ISENABLER {
        const OFFSET: usize = 0x0100;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self, idx: u8) -> u32 {
            assert!(idx < 4u16 as u8);
            unsafe {
                ((BASE_ADDRESS + Self::OFFSET) as *const u32)
                    .add(usize::from(idx))
                    .read_volatile()
            }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub unsafe fn write(&self, idx: u8, bits: u32) {
            assert!(idx < 4u16 as u8);
            unsafe {
                ((BASE_ADDRESS + Self::OFFSET) as *mut u32)
                    .add(usize::from(idx))
                    .write_volatile(bits)
            }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub unsafe fn rmw(&self, idx: u8, f: impl FnOnce(u32) -> u32) {
            self.write(idx, f(self.read(idx)))
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address(idx: u8) -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).add(usize::from(idx)) }
        }
    }
    #[doc = "Interrupt Priority Registers (128 instances)"]
    #[allow(non_camel_case_types)]
    pub struct IPRIORITYR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl IPRIORITYR {
        const OFFSET: usize = 0x0400;
        #[doc = r" Performs a single load operation on the memory-mapped register"]
        pub fn read(&self, idx: u8) -> u8 {
            assert!(idx < 128u16 as u8);
            unsafe {
                ((BASE_ADDRESS + Self::OFFSET) as *const u8)
                    .add(usize::from(idx))
                    .read_volatile()
            }
        }
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub unsafe fn write(&self, idx: u8, bits: u8) {
            assert!(idx < 128u16 as u8);
            unsafe {
                ((BASE_ADDRESS + Self::OFFSET) as *mut u8)
                    .add(usize::from(idx))
                    .write_volatile(bits)
            }
        }
        #[doc = r" Performs a read-modify-write on the memory-mapped register"]
        #[doc = r""]
        #[doc = r" This is a short-hand for `self.write(f(self.read()))`"]
        #[allow(unused_unsafe)]
        pub unsafe fn rmw(&self, idx: u8, f: impl FnOnce(u8) -> u8) {
            self.write(idx, f(self.read(idx)))
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address(idx: u8) -> *mut u8 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u8).add(usize::from(idx)) }
        }
    }
    #[doc = "Software Generated Interrupt Register"]
    #[allow(non_camel_case_types)]
    pub struct SGIR {
        _not_send_or_sync: PhantomData<*mut ()>,
    }
    impl SGIR {
        const OFFSET: usize = 0x0f00;
        #[doc = r" Performs a single store operation on the memory-mapped register"]
        #[allow(unused_unsafe)]
        pub fn write(&self, bits: u32) {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32).write_volatile(bits) }
        }
        #[doc = r" Returns the address of this register"]
        #[allow(unused_parens)]
        #[allow(unused_unsafe)]
        pub fn address() -> *mut u32 {
            unsafe { ((BASE_ADDRESS + Self::OFFSET) as *mut u32) }
        }
    }
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r""]
        #[doc = r" Creates a singleton from thin air; make sure we"]
        #[doc = r" never hand out two instances of it"]
        unsafe fn new() -> Self {
            Self {
                _not_sync: PhantomData,
                CTLR: CTLR {
                    _not_send_or_sync: PhantomData,
                },
                ISENABLER: ISENABLER {
                    _not_send_or_sync: PhantomData,
                },
                IPRIORITYR: IPRIORITYR {
                    _not_send_or_sync: PhantomData,
                },
                SGIR: SGIR {
                    _not_send_or_sync: PhantomData,
                },
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "GICD"]
    pub type GICD = Registers;
    impl GICD {
        #[doc = r" Takes the singleton that represents this peripheral instance"]
        pub fn take() -> Option<Self> {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            if TAKEN
                .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
                .is_ok()
            {
                Some(unsafe { Registers::new() })
            } else {
                None
            }
        }
        #[doc = r" Borrows the singleton without checking if it's"]
        #[doc = r" currently being held by a context"]
        #[doc = r""]
        #[doc = r" **WARNING** this can break Read-Modify-Write"]
        #[doc = r" operations being performed in other contexts."]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(&Registers {
                _not_sync: PhantomData,
                CTLR: CTLR {
                    _not_send_or_sync: PhantomData,
                },
                ISENABLER: ISENABLER {
                    _not_send_or_sync: PhantomData,
                },
                IPRIORITYR: IPRIORITYR {
                    _not_send_or_sync: PhantomData,
                },
                SGIR: SGIR {
                    _not_send_or_sync: PhantomData,
                },
            })
        }
    }
}
