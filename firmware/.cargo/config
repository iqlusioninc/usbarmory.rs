[target.'cfg(all(target_arch = "arm", target_os = "none"))']

# Some examples can be run in QEMU when no real hardware is available.
#runner = "qemu-system-arm -cpu cortex-a7 -machine mcimx6ul-evk -nographic -semihosting-config enable=on,target=native -kernel"

# For running on real hardware, the easiest way is to use the `runner` utility
# like shown here.
# Yes, this uses Cargo as the runner invoked by Cargo. It looks a bit funny but
# does seem to work. It might break when using `cargo +version run` though.
runner = "cargo run --target x86_64-unknown-linux-gnu --manifest-path ../../host/runner/Cargo.toml --"

rustflags = [
  "-C", "linker=flip-lld",
  "-C", "link-arg=-Tlink.x",

  # We need a libc since we depend on C code (littlefs2). This is probably not very portable, but
  # there are not many ways to fix that. One way would be to link with GCC instead of (flip-)lld,
  # which automatically populates search paths like this.
  "-C", "link-arg=-L/usr/arm-none-eabi/lib",
  "-C", "link-arg=-lc",
]

[build]
target = "armv7a-none-eabi" # soft float ABI, emulated float operations
# target = "armv7a-none-eabihf" # hard float ABI, float operations on hardware
